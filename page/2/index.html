<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Welcome to my blog">
<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Welcome to my blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="OwlllOvO">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">OwlllOvO&#39;s Blog</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-2021-7-20-数位-DP" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/07/20/2021-7-20-shu-wei-dp/" class="article-date">
  <time class="dt-published" datetime="2021-07-20T12:38:00.000Z" itemprop="datePublished">2021-07-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/ACM/">ACM</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/07/20/2021-7-20-shu-wei-dp/">数位 DP</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="数位-DP"><a href="#数位-DP" class="headerlink" title="数位 DP"></a>数位 DP</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>给定区间 [L, R]，求该区间中符合某种条件的数的个数</p>
<ul>
<li><p>与数的大小无关，与数的每一位的组成有关</p>
</li>
<li><p>本质：搜索 + 记忆化</p>
</li>
<li><p>用 f[n] 记录 [0, n] 之间满足条件的书的个数，结果：f[R] - f[L - 1]</p>
</li>
</ul>
<h2 id="HDU-2089-·-不要-62"><a href="#HDU-2089-·-不要-62" class="headerlink" title="HDU 2089 · 不要 62"></a><a target="_blank" rel="noopener" href="http://acm.hdu.edu.cn/showproblem.php?pid=2089">HDU 2089 · 不要 62</a></h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>给定两个数 L, R，计算 [L, R] 中数位上没有出现 4 或 62（ 连续）的数的个数</p>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><ol>
<li><p>求符合条件的数的个数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> dp[<span class="number">10</span>][<span class="number">10</span>];	<span class="comment">//dp[x][y]：长度为 x，首位为 y 的数中符合条件的个数</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>; l &lt;= <span class="number">7</span>; l++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">4</span>) dp[l][i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">9</span>; j++)</span><br><span class="line">        	&#123;</span><br><span class="line">            	<span class="keyword">if</span> (i == <span class="number">6</span> &amp;&amp; j == <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    dp[l][i] += dp[l - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>求 [0, n] 中符合条件的数的个数</p>
<p>设 n &#x3D; 234</p>
<p><img src="https://cdn.jsdelivr.net/gh/OwlllOvO/Hexo-image/20210721073823.png"></p>
<p>显然答案不是 dp[3][2]，因为三位数以 2 开头的数中包含 235 等大于 234 的数</p>
<p>因此要按如下分段求：</p>
<ul>
<li><code>dp[3][0] + dp[3][1]</code> 求出三位数中 0xx, 1xx</li>
<li><code>dp[2][0] + dp[2][1] + dp[2][2]</code> 求出两位数中 0x, 1x, 2x</li>
<li><code>dp[1][0] + dp[1][1] + dp[1][2] + dp[1][3]</code> 求出一位数中 0, 1, 2, 3</li>
</ul>
<p>但是假如分段中含 4 或者 62 的，如 345，则遇到 4 或 62 就停止，因为</p>
<p>继续细分出的段的高位肯定包含了 4 或 62</p>
<ul>
<li><code>dp[3][0] + dp[3][1] + dp[3][2]</code> 求出三位数中 0xx, 1xx, 2xx</li>
<li><code>dp[2][0] + dp[2][1] + dp[2][2] + dp[2][3]</code> 求出两位数中 0x, 1x, 2x, 3x</li>
</ul>
</li>
</ol>
<h3 id="Accepted-Code"><a href="#Accepted-Code" class="headerlink" title="Accepted Code"></a>Accepted Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRTSECURE_NOWARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:4996)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m, n;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> d[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>; l &lt;= <span class="number">7</span>; l++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (i == <span class="number">4</span>) dp[l][i] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">9</span>; j++)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span> (i == <span class="number">6</span> &amp;&amp; j == <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">					<span class="keyword">else</span></span><br><span class="line">					&#123;</span><br><span class="line">						dp[l][i] += dp[l - <span class="number">1</span>][j];</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (n)</span><br><span class="line">	&#123;</span><br><span class="line">		++len;</span><br><span class="line">		d[len] = n % <span class="number">10</span>;</span><br><span class="line">		n /= <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	d[len + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = len; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; d[i]; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (d[i + <span class="number">1</span>] != <span class="number">6</span> || j != <span class="number">2</span>)</span><br><span class="line">				ans += dp[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (d[i] == <span class="number">4</span> || (d[i + <span class="number">1</span>] == <span class="number">6</span> &amp;&amp; d[i] == <span class="number">2</span>))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">Init</span>();</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;m, &amp;n);</span><br><span class="line">		<span class="keyword">if</span> (!n &amp;&amp; !m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">get</span>(n + <span class="number">1</span>) - <span class="built_in">get</span>(m));</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="SCOI-2009-·-Windy-数"><a href="#SCOI-2009-·-Windy-数" class="headerlink" title="SCOI 2009 · Windy 数"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2657">SCOI 2009 · Windy 数</a></h2><h3 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h3><p>给定一个区间 [L, R]，求其中满足条件不含前导 0 且相邻两个数字相差至少为 2 的数字个数。</p>
<h3 id="Accepted-Code-1"><a href="#Accepted-Code-1" class="headerlink" title="Accepted Code"></a>Accepted Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRTSECURE_NOWARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:4996)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line"><span class="type">int</span> a[<span class="number">11</span>], p, q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; i++) dp[<span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">2</span>; l &lt;= <span class="number">10</span>; l++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">9</span>; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (<span class="built_in">abs</span>(i - j) &gt;= <span class="number">2</span>) dp[l][i] += dp[l - <span class="number">1</span>][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">work</span><span class="params">(<span class="type">int</span> x)</span>	<span class="comment">//计算 &lt;=x 的 windy 数 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in">sizeof</span>(a));</span><br><span class="line">	<span class="type">int</span> len = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (x)</span><br><span class="line">	&#123;</span><br><span class="line">		a[++len] = x % <span class="number">10</span>;</span><br><span class="line">		x /= <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//分为几个板块 先求 len - 1 位的 windy 数 必定包含在区间里的 </span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len - <span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">9</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			ans += dp[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//然后是 len 位 但最高位 &lt; a[len] 的 windy 数 也包含在区间里 </span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; a[len]; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		ans += dp[len][i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//接着是 len 位 最高位与原数相同的 最难搞的一部分 </span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//i 从最高位后开始枚举 </span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= a[i] - <span class="number">1</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//j 是 i 位上的数 </span></span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">abs</span>(j - a[i + <span class="number">1</span>]) &gt;= <span class="number">2</span>)	ans += dp[i][j]; <span class="comment">//判断和上一位 (i + 1) 相差 2 以上</span></span><br><span class="line">			   <span class="comment">//如果是 ans 就累加 </span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">abs</span>(a[i + <span class="number">1</span>] - a[i]) &lt; <span class="number">2</span>) <span class="keyword">break</span>;</span><br><span class="line">		<span class="comment">//  if(i == 1)   ans += 1;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">Init</span>();</span><br><span class="line">	cin &gt;&gt; p &gt;&gt; q;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">work</span>(q + <span class="number">1</span>) - <span class="built_in">work</span>(p) &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/07/20/2021-7-20-shu-wei-dp/" data-id="clz6fe7hw00290loxgsdk7ra1" data-title="数位 DP" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E4%BD%8D-DP/" rel="tag">数位 DP</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-2021-5-24-归并排序" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/24/2021-5-24-gui-bing-pai-xu/" class="article-date">
  <time class="dt-published" datetime="2021-05-24T11:08:16.000Z" itemprop="datePublished">2021-05-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/ACM/">ACM</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/24/2021-5-24-gui-bing-pai-xu/">归并排序</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>归并排序 · Merge Sort，是建立在归并操作上的一种有效，稳定的排序算法，该算法是采用分治法 · Divide and Conquer 的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</p>
<h2 id="归并操作"><a href="#归并操作" class="headerlink" title="归并操作"></a>归并操作</h2><p>归并操作，也叫归并算法，指的是将两个顺序序列合并成一个顺序序列的方法。</p>
<p>如：设有数列 { 6, 202, 100, 301, 38, 8, 1 }</p>
<p>初始状态：6, 202, 100, 301, 38, 8, 1</p>
<p>第一次归并后：{ 6, 202 }, { 100, 301 }, { 8, 38 }, { 1 }，比较次数：3；</p>
<p>第二次归并后：{ 6, 100, 202, 301 }, { 1, 8, 38 }，比较次数：4；</p>
<p>第三次归并后：{ 1, 6, 8, 38, 100, 202, 301 }，比较次数：4；</p>
<p>总的比较次数为：3 + 4 + 4 &#x3D; 11；</p>
<p>逆序数为 14；</p>
<h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><p>归并操作的工作原理如下：</p>
<ol>
<li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</li>
<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</li>
<li>重复步骤 3 直到某一指针超出序列尾</li>
<li>将另一序列剩下的所有元素直接复制到合并序列尾</li>
</ol>
<h2 id="逆序对"><a href="#逆序对" class="headerlink" title="逆序对"></a>逆序对</h2><p>设 A 为一个有 $n(n \ &gt; \ 1)$ 个数字的有序集，其中所有数字各不相同。</p>
<p>如果存在正整数 i, j 使得 1 ≤ i &lt; j ≤ n 而且 A[i] &gt; A[j]，则（A[i], A[j]）这个有序对称为 A 的一个逆序对，也称作逆序数。</p>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRTSECURE_NOWARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:4996)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, a[<span class="number">100005</span>], tmpA[<span class="number">100005</span>], cnt;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> *A)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">merge_sort</span>(l, mid, A);</span><br><span class="line">    <span class="built_in">merge_sort</span>(mid + <span class="number">1</span>, r, A);</span><br><span class="line">    <span class="type">int</span> pl = l, pr = mid + <span class="number">1</span>, tmpp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(pl &lt;= mid &amp;&amp; pr &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[pl] &lt;= A[pr]) tmpA[tmpp++] = A[pl++];</span><br><span class="line">        <span class="keyword">else</span> tmpA[tmpp++] = A[pr++], cnt += mid - pl + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(pl &lt;= mid) tmpA[tmpp++] = A[pl++];</span><br><span class="line">    <span class="keyword">while</span>(pr &lt;= r) tmpA[tmpp++] = A[pr++];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; tmpp; i++) A[i + l] = tmpA[i];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="built_in">merge_sort</span>(<span class="number">1</span>, n, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, cnt);    <span class="comment">//cnt：逆序对个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/24/2021-5-24-gui-bing-pai-xu/" data-id="clz6fe7hv001z0lox4vih5y22" data-title="归并排序" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/" rel="tag">归并排序</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%80%86%E5%BA%8F%E5%AF%B9/" rel="tag">逆序对</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-2021-5-19-字典树" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/19/2021-5-19-zi-dian-shu/" class="article-date">
  <time class="dt-published" datetime="2021-05-19T05:40:10.000Z" itemprop="datePublished">2021-05-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/ACM/">ACM</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/19/2021-5-19-zi-dian-shu/">字典树</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h1><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TRIE</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> nex[<span class="number">100000</span>][<span class="number">26</span>], cnt;</span><br><span class="line">	<span class="type">bool</span> exist[<span class="number">100000</span>];  <span class="comment">// 该结点结尾的字符串是否存在</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span>* s, <span class="type">int</span> l)</span>  <span class="comment">// 插入字符串</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; l; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> c = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">			<span class="keyword">if</span> (!nex[p][c]) nex[p][c] = ++cnt;  <span class="comment">// 如果没有，就添加结点</span></span><br><span class="line">			p = nex[p][c];</span><br><span class="line">		&#125;</span><br><span class="line">		exist[p] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">char</span>* s, <span class="type">int</span> l)</span>  <span class="comment">// 查找字符串</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; l; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> c = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">			<span class="keyword">if</span> (!nex[p][c]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			p = nex[p][c];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> exist[p];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="于是他错误的点名开始了"><a href="#于是他错误的点名开始了" class="headerlink" title="于是他错误的点名开始了"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2580">于是他错误的点名开始了</a></h2><h3 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h3><p>XS 中学化学竞赛组教练是一个酷爱炉石的人。</p>
<p>他会一边搓炉石一边点名以至于有一天他连续点到了某个同学两次，然后正好被路过的校长发现了然后就是一顿欧拉欧拉欧拉（详情请见已结束比赛 CON900）。</p>
<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>这之后校长任命你为特派探员，每天记录他的点名。校长会提供化学竞赛学生的人数和名单，而你需要告诉校长他有没有点错名。（为什么不直接不让他玩炉石。）</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行一个整数 n，表示班上人数。</p>
<p>接下来 n 行，每行一个字符串表示其名字（互不相同，且只含小写字母，长度不超过 50）。</p>
<p>第 n + 2 行一个整数 m，表示教练报的名字个数。</p>
<p>接下来 m 行，每行一个字符串表示教练报的名字（只含小写字母，且长度不超过 50）。</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>对于每个教练报的名字，输出一行。</p>
<p>如果该名字正确且是第一次出现，输出 <code>OK</code>，如果该名字错误，输出 <code>WRONG</code>，如果该名字正确但不是第一次出现，输出 <code>REPEAT</code>。</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">5  </span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">ad</span><br><span class="line">acd</span><br><span class="line">3</span><br><span class="line">a</span><br><span class="line">a</span><br><span class="line">e</span><br></pre></td></tr></table></figure>



<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OK</span><br><span class="line">REPEAT</span><br><span class="line">WRONG</span><br></pre></td></tr></table></figure>



<h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><ul>
<li>对于 40% 的数据，$n \ \leq 1000, \ m \ \leq \ 2000$</li>
<li>对于 70% 的数据，$n \ \leq 10^{4}, \ m \ \leq \ 2 \ \times \ 10^{4}$</li>
<li>对于 100% 的数据，$n \ \leq 10^{4}, \ m \ \leq \ 2 \ \times \ 10^{5}$</li>
</ul>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>Trie</p>
<p>把模板中的标记数组 exist 改成 int，插入时标记为 1，查询时每查询一次 +1 即可判断是否 REPEAT</p>
<h3 id="Accepted-Code"><a href="#Accepted-Code" class="headerlink" title="Accepted Code"></a>Accepted Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRTSECURE_NOWARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:4996)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> x[<span class="number">101</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TRIE</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> nex[<span class="number">10000000</span>][<span class="number">26</span>], cnt;</span><br><span class="line">	<span class="type">int</span> exist[<span class="number">10000000</span>];  <span class="comment">// 该结点结尾的字符串是否存在</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span>* s, <span class="type">int</span> l)</span>  <span class="comment">// 插入字符串</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; l; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> c = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">			<span class="keyword">if</span> (!nex[p][c]) nex[p][c] = ++cnt;  <span class="comment">// 如果没有，就添加结点</span></span><br><span class="line">			p = nex[p][c];</span><br><span class="line">		&#125;</span><br><span class="line">		exist[p] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">char</span>* s, <span class="type">int</span> l)</span>  <span class="comment">// 查找字符串</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; l; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> c = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">			<span class="keyword">if</span> (!nex[p][c]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			p = nex[p][c];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (exist[p]) <span class="keyword">return</span> exist[p]++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TRIE trie;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">while</span> (n--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, x);</span><br><span class="line">		<span class="type">int</span> l = <span class="built_in">strlen</span>(x);</span><br><span class="line">		trie.<span class="built_in">insert</span>(x, l);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">while</span> (n--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, x);</span><br><span class="line">		<span class="type">int</span> l = <span class="built_in">strlen</span>(x);</span><br><span class="line">		<span class="type">int</span> ans = trie.<span class="built_in">find</span>(x, l);</span><br><span class="line">		<span class="keyword">if</span> (ans)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (ans == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;OK\n&quot;</span>);</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;REPEAT\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;WRONG\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/19/2021-5-19-zi-dian-shu/" data-id="clz6fe7hu001t0loxhwp6820s" data-title="字典树" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Trie/" rel="tag">Trie</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-2021-5-17-图" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/17/2021-5-17-tu/" class="article-date">
  <time class="dt-published" datetime="2021-05-17T11:01:00.000Z" itemprop="datePublished">2021-05-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/ACM/">ACM</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/17/2021-5-17-tu/">图</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><p><strong>图 · Graph</strong> 是一个二元组 $G \ &#x3D; \ (V(G), \ E(G))$。其中 $V(G)$ 是非空集，称为 <strong>点集 · Vertex set</strong>，对于 V 中的每个元素，我们称其为 <strong>顶点 · Vertex</strong> 或 <strong>节点 · Node</strong>，简称 <strong>点</strong>；$E(G)$ 为 $V(G)$ 各结点之间边的集合，称为 <strong>边集 · Edge set</strong>。</p>
<p>常用 $G \ &#x3D; \ (V, \ E)$ 表示图。</p>
<p>当 V, E 都是有限集合时，称 G 为 <strong>有限图</strong>。</p>
<p>当 V 或 E 是无限集合时，称 G 为 <strong>无限图</strong>。</p>
<p>图有多种，包括 <strong>无向图 · Undirected graph</strong>，<strong>有向图 · Directed graph</strong>，<strong>混合图 · Mixed graph</strong> 等</p>
<ul>
<li>若 G 为无向图，则 E 中的每个元素为一个无序二元组 $(u, \ v)$，称作 <strong>无向边 · Undirected edge</strong>，简称 <strong>边 · Edge</strong>，其中 $u, \ v \ \in \ V$。设 $e \ &#x3D; \ (u, \ v)$，则 u 和 v 称为 e 的<strong>端点 · Endpoint</strong>。</li>
<li>若 G 为有向图，则 E 中的每一个元素为一个有序二元组 $(u, \ v)$，有时也写作 $u \ \rightarrow \ v$，称作 <strong>有向边 · Directed edge</strong> 或 <strong>弧 · Arc</strong>，在不引起混淆的情况下也可以称作 <strong>边 · Edge</strong>。设 $e \ &#x3D; \ u \ \rightarrow \ v$，则此时 u 称为 e 的 <strong>起点 · Tail</strong>，v 称为 e 的 <strong>终点 · Head</strong>，起点和终点也称为 e 的 <strong>端点 · Endpoint</strong>。并称 u 是 v 的直接前驱，v 是 u 的直接后继。</li>
<li>若 G 为混合图，则 E 中既有向边，又有无向边。</li>
<li>若 G 的每条边 $e_{k} \ &#x3D; \ (u_{k}, \ v_{k})$ 都被赋予一个数作为该边的 <strong>权</strong>，则称 G 为 <strong>赋权图</strong>。如果这些权都是正实数，就称 G 为 <strong>正权图</strong>。</li>
</ul>
<p>图 G 的点数 $|V(G)|$ 也被称作图 G 的 <strong>阶 · Order</strong>。</p>
<p>形象地说，图是由若干点以及连接点与点的边构成的。</p>
<h3 id="度数"><a href="#度数" class="headerlink" title="度数"></a>度数</h3><p>与一个顶点 v 关联的边的条数称作该顶点的 <strong>度 · Degree</strong>，记作 $d(v)$。特别地，对于边 $(u, \ v)$，则每条这样的边要对 $d(v)$ 产生 2 的贡献。</p>
<p>对于无向简单图，有 $d(v) \ &#x3D; \ |N(v)|$。</p>
<p>握手定理（又称图论基本定理）：对于任何无向图 $G \ &#x3D; \ (V, \ E)$，有 $\sum_{v \ \in \ V}d(v) \ &#x3D; \ 2|E|$。</p>
<p>推论：在任意图中，度数为奇数的点必然有偶数个。</p>
<p>在有向图 $G \ &#x3D; \ (V, \ E)$ 中，以一个顶点 v 为起点的边的条数称为该顶点的 <strong>出度 · Out-degree</strong>，记作 $d^{+}(v)$。以一个顶点 v 为终点的边的条数称为该节点的 <strong>入度 · In-degree</strong>，记作 $d^{-}(v)$。显然 $d^{+}(v) \ + \ d^{-}(v) \ &#x3D;  \ d(v)$。</p>
<p>对于任何有向图 $G \ &#x3D; \ (V, \ E)$，有：$\sum_{v \ \in \ V}d^{+}(v) \ &#x3D; \ \sum_{v \ \in \ V}d^{-}(v) \ &#x3D; \ |E|$</p>
<h3 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h3><p>Chain · 链：一个点和边的交错序列 v<sub>0</sub> - e<sub>1</sub> - v<sub>1</sub> - e<sub>2</sub> - v<sub>2</sub> - … - e<sub>k</sub> - v<sub>k</sub></p>
<p>Trail · 迹：对于一条路径 w，若e<sub>1</sub>, e<sub>2</sub>, …, e<sub>k</sub> 两两互不相同，则 w 是一条迹</p>
<p>Path · 路径：对于一条迹 w，除了 v<sub>0</sub> 和 v<sub>k</sub> 允许相同外，其余点两两互不相同，则称 w 是一条路径</p>
<p>Circuit · 回路：对于一个迹 w，若 v<sub>0</sub> &#x3D; v<sub>k</sub>，则称 w 是一个回路</p>
<p>Cycle · 环：对于一条路径 w，若 v<sub>0</sub> &#x3D; v<sub>k</sub>，则称 w 是一个环</p>
<h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><h3 id="存边"><a href="#存边" class="headerlink" title="存边"></a>存边</h3><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>使用一个数组来存边，数组中的每个元素都包含一条边的起点与终点（带边权的图还包含边权）。（或者使用多个数组分别存起点，终点和边权。）</p>
<h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> u, v;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">vector&lt;Edge&gt; e;</span><br><span class="line">vector&lt;<span class="type">bool</span>&gt; vis;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find_edge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (e[i].u == u &amp;&amp; e[i].v == v)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (vis[u]) <span class="keyword">return</span>;</span><br><span class="line">	vis[u] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (e[i].u == u)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">dfs</span>(e[i].v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">	vis.<span class="built_in">resize</span>(n + <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">	e.<span class="built_in">resize</span>(m + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) cin &gt;&gt; e[i].u &gt;&gt; e[i].v;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h4><p>查询是否存在某条边：$O(m)$。</p>
<p>遍历一个点的所有出边：$O(m)$。</p>
<p>遍历整张图：$O(nm)$。</p>
<p>空间复杂度：$O(m)$。</p>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>由于直接存边的遍历效率低下，一般不用于遍历图。</p>
<p>在 Kruskal 算法中，由于需要将边按边权排序，需要直接存边。</p>
<p>在有的题目中，需要多次建图（如建一遍原图，建一遍反图），此时既可以使用多个其它数据结构来同时存储多张图，也可以将边直接存下来，需要重新建图时利用直接存下的边来建图。</p>
<h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><p>使用一个二维数组 <code>adj</code> 来存边，其中 <code>adj[u][v]</code> 为 1 表示存在 到 的边，为 0 表示不存在。如果是带边权的图，可以在 <code>adj[u][v]</code> 中存储 u 到 v 的边的边权。</p>
<h4 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">vector&lt;<span class="type">bool</span>&gt; vis;</span><br><span class="line">vector&lt;vector&lt;<span class="type">bool</span>&gt; &gt; adj;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find_edge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123; <span class="keyword">return</span> adj[u][v]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (vis[u]) <span class="keyword">return</span>;</span><br><span class="line">	vis[u] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">1</span>; v &lt;= n; ++v)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (adj[u][v])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">dfs</span>(v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">	vis.<span class="built_in">resize</span>(n + <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">	adj.<span class="built_in">resize</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n + <span class="number">1</span>, <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> u, v;</span><br><span class="line">		cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">		adj[u][v] = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h4><p>查询是否存在某条边：$O(1)$。</p>
<p>遍历一个点的所有出边：$O(n)$。</p>
<p>遍历整张图：$O(n^{2})$。</p>
<p>空间复杂度：$O(n^{2})$。</p>
<h4 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h4><p>邻接矩阵只适用于没有重边（或重边可以忽略）的情况。</p>
<p>其最显著的优点是可以 $O(1)$ 查询一条边是否存在。</p>
<p>由于邻接矩阵在稀疏图上效率很低（尤其是在点数较多的图上，空间无法承受），所以一般只会在稠密图上使用邻接矩阵。</p>
<h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><h4 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h4><p>使用一个支持动态增加元素的数据结构构成的数组，如 <code>vector&lt;int&gt; adj[n + 1]</code> 来存边，其中 <code>adj[u]</code> 存储的是点 的所有出边的相关信息（终点、边权等）。</p>
<h4 id="模板-2"><a href="#模板-2" class="headerlink" title="模板"></a>模板</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">vector&lt;<span class="type">bool</span>&gt; vis;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; adj;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find_edge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; adj[u].<span class="built_in">size</span>(); ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (adj[u][i] == v)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (vis[u]) <span class="keyword">return</span>;</span><br><span class="line">	vis[u] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; adj[u].<span class="built_in">size</span>(); ++i) <span class="built_in">dfs</span>(adj[u][i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">	vis.<span class="built_in">resize</span>(n + <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">	adj.<span class="built_in">resize</span>(n + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> u, v;</span><br><span class="line">		cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">		adj[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="复杂度-2"><a href="#复杂度-2" class="headerlink" title="复杂度"></a>复杂度</h4><p>查询是否存在 u 到 v 的边：$O(d^{+}(u))$（如果事先进行了排序就可以使用二分查找做到 ）。</p>
<p>遍历点 u 的所有出边：$O(d^{+}(u))$。</p>
<p>遍历整张图：$O(n \ + \ m)$。</p>
<p>空间复杂度：$O(m)$。</p>
<h4 id="应用-2"><a href="#应用-2" class="headerlink" title="应用"></a>应用</h4><p>存各种图都很适合，除非有特殊需求（如需要快速查询一条边是否存在，且点数较少，可以使用邻接矩阵）。</p>
<p>尤其适用于需要对一个点的所有出边进行排序的场合。</p>
<h3 id="链式前向星"><a href="#链式前向星" class="headerlink" title="链式前向星"></a>链式前向星</h3><h4 id="模板-3"><a href="#模板-3" class="headerlink" title="模板"></a>模板</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRTSECURE_NOWARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:4996)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;	<span class="comment">//n 个点，m 条单向边</span></span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="type">int</span> front[<span class="number">10001</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EDGE</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> to, next, w;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">EDGE edge[<span class="number">10001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(front, <span class="number">0</span>, <span class="built_in">sizeof</span>(front));</span><br><span class="line">	cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	++cnt;</span><br><span class="line">	edge[cnt].to = v;</span><br><span class="line">	edge[cnt].w = w;</span><br><span class="line">	edge[cnt].next = front[u];</span><br><span class="line">	front[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">	<span class="built_in">Init</span>();</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> u, v, w;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">		<span class="built_in">add_edge</span>(u, v, w);</span><br><span class="line">		<span class="built_in">add_edge</span>(v, u, w);	<span class="comment">//双向边</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历与每个点相连的所有边</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = front[i]; j; j = edge[j].next)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, i, edge[j].to, edge[j].w);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="复杂度-3"><a href="#复杂度-3" class="headerlink" title="复杂度"></a>复杂度</h4><p>查询是否存在 u 到 v 的边：$O(d^{+}(u))$。</p>
<p>遍历点 的所有出边：$O(d^{+}(u))$。</p>
<p>遍历整张图：$O(n \ + \ m)$。</p>
<p>空间复杂度：$O(m)$。</p>
<h4 id="应用-3"><a href="#应用-3" class="headerlink" title="应用"></a>应用</h4><p>存各种图都很适合，但不能快速查询一条边是否存在，也不能方便地对一个点的出边进行排序。</p>
<p>优点是边是带编号的，有时会非常有用，而且如果 <code>cnt</code> 的初始值为奇数，存双向边时 <code>i ^ 1</code> 即是 <code>i</code> 的反边（常用于网络流）。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/17/2021-5-17-tu/" data-id="clz6fe7hu001r0lox32sygtn7" data-title="图" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%9B%BE/" rel="tag">图</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-2021-5-13-AC-自动机" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/13/2021-5-13-ac-zi-dong-ji/" class="article-date">
  <time class="dt-published" datetime="2021-05-13T06:12:35.000Z" itemprop="datePublished">2021-05-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/ACM/">ACM</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/13/2021-5-13-ac-zi-dong-ji/">AC 自动机</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="AC-自动机"><a href="#AC-自动机" class="headerlink" title="AC 自动机"></a>AC 自动机</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>AC 自动机是以 Trie 的结构为基础，结合 KMP 的思想建立的。</p>
<p>简单来说，建立一个 AC 自动机有两个步骤：</p>
<ol>
<li>基础的 Trie 结构：将所有的模式串构成一棵 Trie。</li>
<li>KMP 的思想：对 Trie 树上所有的结点构造失配指针。</li>
</ol>
<p>然后就可以利用它进行多模式匹配了。</p>
<h2 id="构建字典树"><a href="#构建字典树" class="headerlink" title="构建字典树"></a>构建字典树</h2><p>AC 自动机在初始时会将若干个模式串丢到一个 Trie 里，然后在 Trie 上建立 AC 自动机。这个 Trie 就是普通的 Trie，该怎么建怎么建。</p>
<p>这里需要仔细解释一下 Trie 的结点的含义，尽管这很小儿科，但在之后的理解中极其重要。Trie 中的结点表示的是某个模式串的前缀。我们在后文也将其称作状态。一个结点表示一个状态，Trie 的边就是状态的转移。</p>
<p>形式化地说，对于若干个模式串 $s_{1}, \ s_{2}, \ \cdots, \ s_{n}$，将它们构建一棵字典树后的所有状态的集合记作 $Q$。</p>
<h2 id="失配指针"><a href="#失配指针" class="headerlink" title="失配指针"></a>失配指针</h2><p>AC 自动机利用一个 fail 指针来辅助多模式串的匹配。</p>
<p>状态 $u$ 的 fail 指针指向另一个状态 $v$，其中 $v \ \in \ Q$，且 $v$ 是 $u$ 的最长后缀（即在若干个后缀状态中取最长的一个作为 fail 指针）。fail 指针与 KMP 中的 next 指针：</p>
<ul>
<li>共同点：两者同样是在失配的时候用于跳转的指针。</li>
<li>不同点：next 指针求的是最长 Border（即最长的相同前后缀），而 fail 指针指向所有模式串的前缀中匹配当前状态的最长后缀。</li>
</ul>
<p>因为 KMP 只对一个模式串做匹配，而 AC 自动机要对多个模式串做匹配。有可能 fail 指针指向的结点对应着另一个模式串，两者前缀不同。</p>
<p>AC 自动机的失配指针指向当前状态的最长后缀状态</p>
<p>AC 自动机在做匹配时，同一位上可匹配多个模式串。</p>
<h3 id="构建指针"><a href="#构建指针" class="headerlink" title="构建指针"></a>构建指针</h3><p>下面介绍构建 fail 指针的基础思想（强调！基础思想！基础！）：</p>
<p>构建 fail 指针，可以参考 KMP 中构造 Next 指针的思想。</p>
<p>考虑字典树中当前的结点 $u$ ，$u$ 的父结点是 $p$，$p$ 通过字符 <code>c</code> 的边指向 $u$，即 trie[p, c] &#x3D; u。假设深度小于 $u$ 的所有结点的 fail 指针都已求得。</p>
<ol>
<li>如果 trie[fail[p], c] 存在：则让 u 的 fail 指针指向 trie[fail[p], c]。相当于在 $p$ 和 fail[p] 后面加一个字符 <code>c</code>，分别对应 $u$ 和 fail[u]。</li>
<li>如果 trie[fail[p], c] 不存在：那么我们继续找到 trie[fail[fail[p]], c]。重复 1 的判断过程，一直跳 fail 指针直到根结点。</li>
<li>如果真的没有，就让 fail 指针指向根结点。</li>
</ol>
<p>如此即完成了 fail[u] 的构建。</p>
<h2 id="字典树与字典图"><a href="#字典树与字典图" class="headerlink" title="字典树与字典图"></a>字典树与字典图</h2><h3 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h3><p>该函数的目标有两个，一个是构建 fail 指针，一个是构建自动机。参数如下：</p>
<ol>
<li><code>tr[u,c]</code>：有两种理解方式。我们可以简单理解为字典树上的一条边，即 trie[u, c]；也可以理解为从状态（结点）$u$ 后加一个字符 <code>c</code> 到达的状态（结点），即一个状态转移函数 trans(u, c)。下文中我们将用第二种理解方式继续讲解。</li>
<li>队列 <code>q</code>：用于 BFS 遍历字典树。</li>
<li><code>fail[u]</code>：结点 $u$ 的 fail 指针。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">		<span class="keyword">if</span> (tr[<span class="number">0</span>][i]) q.<span class="built_in">push</span>(tr[<span class="number">0</span>][i]);</span><br><span class="line">	<span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (tr[u][i])</span><br><span class="line">				fail[tr[u][i]] = tr[fail[u]][i], q.<span class="built_in">push</span>(tr[u][i]);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				tr[u][i] = tr[fail[u]][i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解释一下上面的代码：build 函数将结点按 BFS 顺序入队，依次求 fail 指针。这里的字典树根结点为 0，我们将根结点的子结点一一入队。若将根结点入队，则在第一次 BFS 的时候，会将根结点儿子的 fail 指针标记为本身。因此我们将根结点的儿子一一入队，而不是将根结点入队。</p>
<p>然后开始 BFS：每次取出队首的结点 u（fail[u] 在之前的 BFS 过程中已求得），然后遍历字符集（这里是 0-25，对应 a-z，即 $u$ 的各个子节点）：</p>
<ol>
<li>如果 trans[u][i] 存在，我们就将 trans[u][i] 的 fail 指针赋值为 trans[fail[u]][i]。这里似乎有一个问题。根据之前的讲解，我们应该用 while 循环，不停的跳 fail 指针，判断是否存在字符 <code>i</code> 对应的结点，然后赋值，但是这里通过特殊处理简化了这些代码。</li>
<li>否则，令 trans[u][i] 指向 trans[fail[u]][i] 的状态。</li>
</ol>
<p>这里的处理是，通过 <code>else</code> 语句的代码修改字典树的结构。没错，它将不存在的字典树的状态链接到了失配指针的对应状态。在原字典树中，每一个结点代表一个字符串 S，是某个模式串的前缀。而在修改字典树结构后，尽管增加了许多转移关系，但结点（状态）所代表的字符串是不变的。</p>
<p>而 trans[S][c] 相当于是在 S 后添加一个字符 <code>c</code> 变成另一个状态 S’。如果 S’ 存在，说明存在一个模式串的前缀是 S’，否则我们让 trans[S][c] 指向 trans[fail[S]][c]。由于 fail[S] 对应的字符串是 S 的后缀，因此 trans[fail[S]][c] 对应的字符串也是 S’ 的后缀。</p>
<p>换言之在 Trie 上跳转的时侯，我们只会从 S 跳转到 S’，相当于匹配了一个 S’；但在 AC 自动机上跳转的时侯，我们会从 S 跳转到 S’ 的后缀，也就是说我们匹配一个字符 <code>c</code>，然后舍弃 S 的部分前缀。舍弃前缀显然是能匹配的。那么 fail 指针呢？它也是在舍弃前缀啊！试想一下，如果文本串能匹配 S，显然它也能匹配 S 的后缀。所谓的 fail 指针其实就是 S 的一个后缀集合。</p>
<p><code>tr</code> 数组还有另一种比较简单的理解方式：如果在位置 $u$ 失配，我们会跳转到 fail[u] 的位置。所以我们可能沿着 fail 数组跳转多次才能来到下一个能匹配的位置。所以我们可以用 <code>tr</code> 数组直接记录记录下一个能匹配的位置，这样就能节省下很多时间。</p>
<p>这样修改字典树的结构，使得匹配转移更加完善。同时它将 fail 指针跳转的路径做了压缩（就像并查集的路径压缩），使得本来需要跳很多次 fail 指针变成跳一次。</p>
<h3 id="多模式匹配"><a href="#多模式匹配" class="headerlink" title="多模式匹配"></a>多模式匹配</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">char</span>* t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> u = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; t[i]; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		u = tr[u][t[i] - <span class="string">&#x27;a&#x27;</span>];  <span class="comment">// 转移</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = u; j &amp;&amp; e[j] != <span class="number">-1</span>; j = fail[j])</span><br><span class="line">		&#123;</span><br><span class="line">			res += e[j], e[j] = <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里 $u$ 作为字典树上当前匹配到的结点，<code>res</code> 即返回的答案。循环遍历匹配串，$u$ 在字典树上跟踪当前字符。利用 fail 指针找出所有匹配的模式串，累加到答案中。然后清零。在上文中我们分析过，字典树的结构其实就是一个 trans 函数，而构建好这个函数后，在匹配字符串的过程中，我们会舍弃部分前缀达到最低限度的匹配。fail 指针则指向了更多的匹配状态。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/13/2021-5-13-ac-zi-dong-ji/" data-id="clz6fe7hu001o0loxe3on1qoc" data-title="AC 自动机" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/AC-%E8%87%AA%E5%8A%A8%E6%9C%BA/" rel="tag">AC 自动机</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-2021-5-10-MathJax" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/10/2021-5-10-mathjax/" class="article-date">
  <time class="dt-published" datetime="2021-05-10T10:55:21.000Z" itemprop="datePublished">2021-05-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/10/2021-5-10-mathjax/">MathJax</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="MathJax"><a href="#MathJax" class="headerlink" title="MathJax"></a>MathJax</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h3><ul>
<li>行内公式（Inline）<code>$...$</code></li>
<li>单独公式（Display）<code>$$...$$</code></li>
</ul>
<h3 id="运算符号"><a href="#运算符号" class="headerlink" title="运算符号"></a>运算符号</h3><table>
<thead>
<tr>
<th>符号</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>$+$</td>
<td><code>+</code></td>
</tr>
<tr>
<td>$-$</td>
<td><code>-</code></td>
</tr>
<tr>
<td>$\times$</td>
<td><code>\times</code></td>
</tr>
<tr>
<td>$\div$</td>
<td><code>\div</code></td>
</tr>
<tr>
<td>$\cdot$</td>
<td><code>\cdot</code></td>
</tr>
<tr>
<td>$\cdots$</td>
<td><code>\cdots</code></td>
</tr>
<tr>
<td>$\pm$</td>
<td><code>\pm</code></td>
</tr>
<tr>
<td>$&#x3D;$</td>
<td><code>=</code></td>
</tr>
<tr>
<td>$&gt;$</td>
<td><code>&gt;</code></td>
</tr>
<tr>
<td>$&lt;$</td>
<td><code>&lt;</code></td>
</tr>
<tr>
<td>$\neq$</td>
<td><code>\neq</code></td>
</tr>
<tr>
<td>$\leq$</td>
<td><code>\leq</code></td>
</tr>
<tr>
<td>$\geq$</td>
<td><code>\geq</code></td>
</tr>
<tr>
<td>$\sum$</td>
<td><code>\sum</code></td>
</tr>
<tr>
<td>$\prod$</td>
<td><code>\prod</code></td>
</tr>
<tr>
<td>$\int$</td>
<td><code>\int</code></td>
</tr>
<tr>
<td>$\iint$</td>
<td><code>\iint</code></td>
</tr>
<tr>
<td>$\iiint$</td>
<td><code>\iiint</code></td>
</tr>
</tbody></table>
<h3 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h3><table>
<thead>
<tr>
<th>字母</th>
<th>命令</th>
<th>字母</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>$\alpha$</td>
<td><code>\alpha</code></td>
<td>$\Alpha$</td>
<td><code>\Alpha</code></td>
</tr>
<tr>
<td>$\beta$</td>
<td><code>\beta</code></td>
<td>$\Beta$</td>
<td><code>\Beta</code></td>
</tr>
<tr>
<td>$\gamma$</td>
<td><code>\gamma</code></td>
<td>$\Gamma$</td>
<td><code>\Gamma</code></td>
</tr>
<tr>
<td>$\delta$</td>
<td><code>\delta</code></td>
<td>$\Delta$</td>
<td><code>\Delta</code></td>
</tr>
<tr>
<td>$\epsilon$</td>
<td><code>\epsilon</code></td>
<td>$\Epsilon$</td>
<td><code>\Epsilon</code></td>
</tr>
<tr>
<td>$\zeta$</td>
<td><code>\zeta</code></td>
<td>$\Zeta$</td>
<td><code>\Zeta</code></td>
</tr>
<tr>
<td>$\eta$</td>
<td><code>\eta</code></td>
<td>$\Eta$</td>
<td><code>\Eta</code></td>
</tr>
<tr>
<td>$\theta$</td>
<td><code>\theta</code></td>
<td>$\Theta$</td>
<td><code>\Theta</code></td>
</tr>
<tr>
<td>$\iota$</td>
<td><code>\iota</code></td>
<td>$\Iota$</td>
<td><code>\Iota</code></td>
</tr>
<tr>
<td>$\kappa$</td>
<td><code>\kappa</code></td>
<td>$\Kappa$</td>
<td><code>\Kappa</code></td>
</tr>
<tr>
<td>$\lambda$</td>
<td><code>\lambda</code></td>
<td>$\Lambda$</td>
<td><code>\Lambda</code></td>
</tr>
<tr>
<td>$\mu$</td>
<td><code>\mu</code></td>
<td>$\Mu$</td>
<td><code>\Mu</code></td>
</tr>
<tr>
<td>$\nu$</td>
<td><code>\nu</code></td>
<td>$\Nu$</td>
<td><code>\Nu</code></td>
</tr>
<tr>
<td>$\xi$</td>
<td><code>\xi</code></td>
<td>$\Xi$</td>
<td><code>\Xi</code></td>
</tr>
<tr>
<td>$\pi$</td>
<td><code>\pi</code></td>
<td>$\Pi$</td>
<td><code>\Pi</code></td>
</tr>
<tr>
<td>$\rho$</td>
<td><code>\rho</code></td>
<td>$\Rho$</td>
<td><code>\Rho</code></td>
</tr>
<tr>
<td>$\sigma$</td>
<td><code>\sigma</code></td>
<td>$\Sigma$</td>
<td><code>\Sigma</code></td>
</tr>
<tr>
<td>$\tau$</td>
<td><code>\tau</code></td>
<td>$\Tau$</td>
<td><code>\Tau</code></td>
</tr>
<tr>
<td>$\upsilon$</td>
<td><code>\upsilon</code></td>
<td>$\Upsilon$</td>
<td><code>\Upsilon</code></td>
</tr>
<tr>
<td>$\phi$</td>
<td><code>\phi</code></td>
<td>$\Phi$</td>
<td><code>\Phi</code></td>
</tr>
<tr>
<td>$\chi$</td>
<td><code>\chi</code></td>
<td>$\Chi$</td>
<td><code>\Chi</code></td>
</tr>
<tr>
<td>$\psi$</td>
<td><code>\psi</code></td>
<td>$\Psi$</td>
<td><code>\Psi</code></td>
</tr>
<tr>
<td>$\omega$</td>
<td><code>\omega</code></td>
<td>$\Omega$</td>
<td><code>\Omega</code></td>
</tr>
</tbody></table>
<h3 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h3><table>
<thead>
<tr>
<th>显示</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>$($</td>
<td><code>(</code></td>
</tr>
<tr>
<td>$)$</td>
<td><code>)</code></td>
</tr>
<tr>
<td>$[$</td>
<td><code>[</code></td>
</tr>
<tr>
<td>$]$</td>
<td><code>]</code></td>
</tr>
<tr>
<td>$\langle$</td>
<td><code>\langle</code></td>
</tr>
<tr>
<td>$\rangle$</td>
<td><code>\rangle</code></td>
</tr>
<tr>
<td>$\lbrace$</td>
<td><code>\lbrace</code></td>
</tr>
<tr>
<td>$\rbrace$</td>
<td><code>\rbrace</code></td>
</tr>
<tr>
<td>$\lceil$</td>
<td><code>\lceil</code></td>
</tr>
<tr>
<td>$\rceil$</td>
<td><code>\rceil</code></td>
</tr>
<tr>
<td>$\lfloor$</td>
<td><code>\lfloor</code></td>
</tr>
<tr>
<td>$\rfloor$</td>
<td><code>\rfloor</code></td>
</tr>
</tbody></table>
<h3 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h3><ul>
<li>上标 <code>^&#123;&#125;</code> $a^{b}$ <code>a^&#123;b&#125;</code></li>
<li>下标 <code>_&#123;&#125;</code> $a_{b}$ <code>a_&#123;b&#125;</code></li>
<li>分数 <code>\frac&#123;&#125;&#123;&#125;</code> $\frac{a}{b}$ <code>\frac&#123;a&#125;&#123;b&#125;</code></li>
<li>根式 <code>\sqrt[]&#123;&#125;</code> $\sqrt[a]{b}$ <code>\sqrt[a]&#123;b&#125;</code></li>
<li>空格<ul>
<li>小空格 <code>\ </code> $a\ b$ <code>a\ b</code></li>
<li>四格空格 <code>\quad</code> $a\quad b$ <code>a\quad b</code></li>
</ul>
</li>
<li>分段 <code>\\</code></li>
</ul>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><table>
<thead>
<tr>
<th>显示</th>
<th>代码</th>
</tr>
</thead>
<tbody><tr>
<td>$\sin$</td>
<td><code>\sin</code></td>
</tr>
<tr>
<td>$\cos$</td>
<td><code>\cos</code></td>
</tr>
<tr>
<td>$\tan$</td>
<td><code>\tan</code></td>
</tr>
<tr>
<td>$\ln$</td>
<td><code>\ln</code></td>
</tr>
<tr>
<td>$\max$</td>
<td><code>\max</code></td>
</tr>
<tr>
<td>$\min$</td>
<td><code>\min</code></td>
</tr>
</tbody></table>
<h3 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h3><table>
<thead>
<tr>
<th>显示</th>
<th>代码</th>
</tr>
</thead>
<tbody><tr>
<td>$\infty$</td>
<td><code>\infty</code></td>
</tr>
<tr>
<td>$\cup$</td>
<td><code>\cup</code></td>
</tr>
<tr>
<td>$\cap$</td>
<td><code>\cap</code></td>
</tr>
<tr>
<td>$\subset$</td>
<td><code>\subset</code></td>
</tr>
<tr>
<td>$\subseteq$</td>
<td><code>\subseteq</code></td>
</tr>
<tr>
<td>$\supset$</td>
<td><code>\supset</code></td>
</tr>
<tr>
<td>$\supseteq$</td>
<td><code>\supseteq</code></td>
</tr>
<tr>
<td>$\in$</td>
<td><code>\in</code></td>
</tr>
<tr>
<td>$\notin$</td>
<td><code>\notin</code></td>
</tr>
<tr>
<td>$\varnothing$</td>
<td><code>\varnothing</code></td>
</tr>
<tr>
<td>$\forall$</td>
<td><code>\forall</code></td>
</tr>
<tr>
<td>$\exists$</td>
<td><code>\exists</code></td>
</tr>
<tr>
<td>$\lnot$</td>
<td><code>\lnot</code></td>
</tr>
<tr>
<td>$\nabla$</td>
<td><code>\nabla</code></td>
</tr>
<tr>
<td>$\partial$</td>
<td><code>\partial</code></td>
</tr>
</tbody></table>
<h3 id="矢量"><a href="#矢量" class="headerlink" title="矢量"></a>矢量</h3><ul>
<li>单字母向量:<ul>
<li><code>\vec a</code> 显示为 $\vec a$</li>
<li><code>\overrightarrow a</code> 显示为 $\overrightarrow a$</li>
</ul>
</li>
<li>多字母向量:<br><code>\vec &#123;ab&#125;</code> 显示为 $\vec {ab}$</li>
<li><code>\overrightarrow &#123;ab&#125;</code> 显示为 $\overrightarrow {ab}$</li>
</ul>
<h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><p>起始标记 <code>\begin&#123;matrix&#125;</code>，结束标记 <code>\end&#123;matrix&#125;</code><br>每一行末尾标记 <code>\\</code>，行间元素之间以 <code>&amp;</code> 分隔</p>
<p>$$\begin{matrix}<br>1&amp;0&amp;0\<br>0&amp;1&amp;0\<br>0&amp;0&amp;1\<br>\end{matrix}$$</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$$</span>\<span class="keyword">begin</span>&#123;matrix&#125;</span><br><span class="line"><span class="number">1</span>&amp;<span class="number">0</span>&amp;<span class="number">0</span>\\</span><br><span class="line"><span class="number">0</span>&amp;<span class="number">1</span>&amp;<span class="number">0</span>\\</span><br><span class="line"><span class="number">0</span>&amp;<span class="number">0</span>&amp;<span class="number">1</span>\\</span><br><span class="line">\<span class="keyword">end</span>&#123;matrix&#125;<span class="variable">$$</span></span><br></pre></td></tr></table></figure>


























      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/10/2021-5-10-mathjax/" data-id="clz6fe7ht001i0loxbk5lh1uc" data-title="MathJax" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MathJax/" rel="tag">MathJax</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/markdown/" rel="tag">markdown</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-2021-5-10-快速幂" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/10/2021-5-10-kuai-su-mi/" class="article-date">
  <time class="dt-published" datetime="2021-05-10T10:44:40.000Z" itemprop="datePublished">2021-05-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/ACM/">ACM</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/10/2021-5-10-kuai-su-mi/">快速幂</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>快速幂，二进制取幂（Binary Exponentiation，也称平方法），是一个在 $O(log \ n)$ 的时间内计算 $a^{n}$ 的小技巧，而暴力的计算需要 $O(n)$ 的时间。而这个技巧也常常用在非计算的场景，因为它可以应用在任何具有结合律的运算中。其中显然的是它可以应用于模意义下取幂、矩阵幂等运算，我们接下来会讨论。</p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>计算 a 的 n 次方表示将 n 个 a 乘在一起： $a^{n} \ &#x3D; a \ \times \ a \ \times \ \cdots \ \times \ a$ （n 个 a）</p>
<p>然而当 a, n 太大的时侯，这种方法就不太适用了。不过我们知道：$a^{b+c} \ &#x3D; \ a^{b}\ \cdot \ a^{c}$, $a^{2b}\ &#x3D;\ a^{b}\ \cdot \ a^{b} \ &#x3D; \ (a^{b})^{2}$。二进制取幂的想法是，我们将取幂的任务按照指数的 <strong>二进制表示</strong> 来分割成更小的任务。</p>
<p>首先我们将 n 表示为 2 进制，举一个例子：</p>
<p>$3^{(13)<em>{10}} \ &#x3D; \ 3^{(1101)</em>{2}} \ &#x3D; \ 3^{8} \ \cdot \ 3^{4} \ \cdot \ 3^{1}$</p>
<p>因为 n 有 $\lfloor \log_{2}n \rfloor \ + \ 1$ 个二进制位，因此当我们知道了 $a^{1}, \ a^{2}, \ a^{4}, \ a^{8}, \ \cdots, \ a^{2^{\lfloor\log_{2}n\rfloor}}, \ $后，我们只用计算 $O(\log n)$ 次乘法就可以计算出 $a^{n}$。</p>
<p>于是我们只需要知道一个快速的方法来计算上述 3 的 $2^{k}$ 次幂的序列。这个问题很简单，因为序列中（除第一个）任意一个元素就是其前一个元素的平方。举一个例子：<br>$$<br>\begin{matrix}<br>3^{1} &amp; &#x3D; &amp; 3\<br>3^{2} &amp; &#x3D; &amp; (3^{1})^{2} &amp; &#x3D; &amp; 3^{2} &amp; &#x3D; &amp; 9\<br>3^{4} &amp; &#x3D; &amp; (3^{2})^{2} &amp; &#x3D; &amp; 9^{2} &amp; &#x3D; &amp; 81\<br>3^{8} &amp; &#x3D; &amp; (3^{4})^{2} &amp; &#x3D; &amp; 81^{2} &amp; &#x3D; &amp; 6561\<br>\end{matrix}<br>$$</p>
<p>因此为了计算 $3^{13}$，我们只需要将对应二进制位为 1 的整系数幂乘起来就行了：</p>
<p>$3^{13} \ &#x3D; \ 6561 \ \cdot \ 81 \ \cdot \ 3\ &#x3D; \ 1594323$</p>
<p>将上述过程说得形式化一些，如果把 n 写作二进制为 $(n_{t}n_{t-1}\cdots n_{1}n_{0})$，那么有：</p>
<p>$n \ &#x3D; \ n_{t}2^{t} \ + \ n_{t-1}2^{t-1} \ + \ n_{t-2}2^{t-2} \ + \ \cdots \ + \ n_{1}2^{1} \ + \ n_{0}2^{0}$</p>
<p>其中 。那么就有</p>
<p>$a^{n} \ &#x3D; \ (a^{n_{t}2^{t} \ + \ \cdots \ + \ n_{0}2^{0}}) \ &#x3D; \ a^{n_{0}2^{0}} \ \times \ a^{n_{1}2^{1}} \ \times \ \cdots \ \times \ a^{n_{t}2^{t}}$</p>
<p>根据上式我们发现，原问题被我们转化成了形式相同的子问题的乘积，并且我们可以在常数时间内从 $2^{i}$ 项推出 $2^{i+1}$ 项。</p>
<p>这个算法的复杂度是 $O(\log n)$ 的，我们计算了 $O(\log n)$ 个 $2^{k}$ 次幂的数，然后花费 $O(\log n)$ 的时间选择二进制为 1 对应的幂来相乘。</p>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><ul>
<li><p>递归法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">binpow</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a, <span class="type">long</span> <span class="type">long</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> res = <span class="built_in">binpow</span>(a, b / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (b % <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> res * res * a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> res * res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>非递归法（稍快）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">binpow</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a, <span class="type">long</span> <span class="type">long</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) res = res * a;</span><br><span class="line">        a = a * a;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="模意义下取幂"><a href="#模意义下取幂" class="headerlink" title="模意义下取幂"></a>模意义下取幂</h3><p>计算 $x^{n} \ mod \ m$</p>
<p>这是一个非常常见的应用，例如它可以用于计算模意义下的乘法逆元。</p>
<p>既然我们知道取模的运算不会干涉乘法运算，因此我们只需要在计算的过程中取模即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">binpow</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a, <span class="type">long</span> <span class="type">long</span> b, <span class="type">long</span> <span class="type">long</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a %= m;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) res = res * a % m;</span><br><span class="line">        a = a * a % m;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：根据费马小定理，如果 m 是一个质数，我们可以计算 $x^{n \ mod \ (m-1)}$ 来加速算法过程。</p>
<h3 id="模意义下大整数乘法"><a href="#模意义下大整数乘法" class="headerlink" title="模意义下大整数乘法"></a>模意义下大整数乘法</h3><p>计算 $a \ \times \ b \ mod \ m, \ a, \ b \ \leq \ m \ \leq \ 10^{18}$</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>








      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/10/2021-5-10-kuai-su-mi/" data-id="clz6fe7hu001m0loxeszwhfun" data-title="快速幂" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/" rel="tag">快速幂</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-2021-5-9-树" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/09/2021-5-9-shu/" class="article-date">
  <time class="dt-published" datetime="2021-05-09T05:27:25.000Z" itemprop="datePublished">2021-05-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/ACM/">ACM</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/09/2021-5-9-shu/">树</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><ul>
<li><p>对于无根树：为每个结点开辟一个线性列表，记录所有与之相连的结点。</p>
<p><code>std::vector&lt;int&gt; adj[N]; </code></p>
</li>
<li><p>对于有根树：</p>
<ul>
<li><p>方法一：若给定的是无向图，则仍可以上述形式存储。下文将介绍如何区分结点的上下关系。</p>
</li>
<li><p>方法二：若输入数据能够确保结点的上下关系，则可以利用这个信息。为每个结点开辟一个线性列表，记录其所有子结点；若有需要，还可在另一个数组中记录其父结点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; children[N];</span><br><span class="line"><span class="type">int</span> parent[N];</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><ul>
<li><p>先序遍历：左中右</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">preTrav</span><span class="params">(BiTree* root)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root) </span><br><span class="line">    &#123;</span><br><span class="line">		cout &lt;&lt; root-&gt;key &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		<span class="built_in">preTrav</span>(root-&gt;left);</span><br><span class="line">		<span class="built_in">preTrav</span>(root-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="树的直径"><a href="#树的直径" class="headerlink" title="树的直径"></a>树的直径</h2><h3 id="两次-DFS"><a href="#两次-DFS" class="headerlink" title="两次 DFS"></a>两次 DFS</h3><p>第一次从任意节点开始 DFS 找到最远的节点 z，第二次从 z 开始 DFS 找到最远的节点 z’，则 dis(z, z’) 为树的直径</p>
<ul>
<li>定理：在一棵树上，从任意节点 y 开始进行一次 DFS，到达的距离其最远的节点 z 必为直径的一端。</li>
<li>不适用于存在负权边的树</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, c, d[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; E[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> v : E[u]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">    d[v] = d[u] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (d[v] &gt; d[c]) c = v;</span><br><span class="line">    <span class="built_in">dfs</span>(v, u);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="type">int</span> u, v;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">    E[u].<span class="built_in">push_back</span>(v), E[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  d[c] = <span class="number">0</span>, <span class="built_in">dfs</span>(c, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, d[c]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="树形-DP"><a href="#树形-DP" class="headerlink" title="树形 DP"></a>树形 DP</h3><p>我们记录当 $1$ 为树的根时，每个节点作为子树的根向下，所能延伸的最远距离 $d_1$，和次远距离 $d_2$，那么直径就是所有 $d_1+d_2$ 的最大值。</p>
<p>树形 DP 可以在存在负权边的情况下求解出树的直径。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, d = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> d1[N], d2[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; E[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">  d1[u] = d2[u] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> v : E[u]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(v, u);</span><br><span class="line">    <span class="type">int</span> t = d1[v] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (t &gt; d1[u])</span><br><span class="line">      d2[u] = d1[u], d1[u] = t;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (t &gt; d2[u])</span><br><span class="line">      d2[u] = t;</span><br><span class="line">  &#125;</span><br><span class="line">  d = <span class="built_in">max</span>(d, d1[u] + d2[u]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="type">int</span> u, v;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">    E[u].<span class="built_in">push_back</span>(v), E[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, d);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="LCA"><a href="#LCA" class="headerlink" title="LCA"></a>LCA</h2><p>树上两个节点的最近公共祖先</p>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ul>
<li>LCA(u) &#x3D; u</li>
<li>若 LCA(u, v) &#x3D; u 则 u 是 v 的祖先</li>
<li>如果 u 不为 v 的祖先并且 v 不为 u 的祖先，那么 u, v 分别处于 LCA(u, v) 的两棵不同子树中</li>
<li>前序遍历中，LCA(S) 出现在所有 S 中元素之前，后序遍历中 LCA(S) 则出现在所有 S 中元素之后</li>
<li>两点集并的最近公共祖先为两点集分别的最近公共祖先的最近公共祖先，即 $LCA(A\cup B)&#x3D;LCA(LCA(A),LCA(b))$ </li>
<li>两点的最近公共祖先必定处在树上两点间的最短路上</li>
<li>$d(u, v) &#x3D; h(u) + h(v) -2h(LCA(u,v))$，其中 d 是树上两点间的距离，h 代表某点到树根的距离</li>
</ul>
<h3 id="在线-·-倍增"><a href="#在线-·-倍增" class="headerlink" title="在线 · 倍增"></a>在线 · 倍增</h3><p>倍增算法是最经典的 LCA 求法，他是朴素算法的改进算法。通过预处理 $fa_{x,i}$ 数组，游标可以快速移动，大幅减少了游标跳转次数。 $fa_{x,i}$  表示点 $x$ 的第 $2^i$ 个祖先。 数组可以通过 DFS 预处理出来。</p>
<p>现在我们看看如何优化这些跳转： 在调整游标的第一阶段中，我们要将 $u, v$ 两点跳转到同一深度。我们可以计算出 $u, v$ 两点的深度之差，设其为 $y$。通过将 $y$ 进行二进制拆分，我们将 $y$ 次游标跳转优化为 <code> 的二进制表示所含 1 的个数</code> 次游标跳转。 在第二阶段中，我们从最大的 $i$ 开始循环尝试，一直尝试到 $0$ （包括 $0$），如果 $fa_{u,i}\neq fa_{v,i}$，则 $u\leftarrow fa_{u,i}, v\leftarrow fa_{v,i}$，那么最后的 LCA 为 $fa_{u,0}$。</p>
<p>倍增算法的预处理时间复杂度为 $O(n\log n)$，单次查询时间复杂度为 $O(\log n)$ 。 另外倍增算法可以通过交换 <code>fa</code> 数组的两维使较小维放在前面。这样可以减少 cache miss 次数，提高程序效率。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MXN 50007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v[MXN];</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; w[MXN];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fa[MXN][<span class="number">31</span>], cost[MXN][<span class="number">31</span>], dep[MXN];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a, b, c;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dfs，用来为 lca 算法做准备。接受两个参数：dfs 起始节点和它的父亲节点。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> root, <span class="type">int</span> fno)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化：第 2^0 = 1 个祖先就是它的父亲节点，dep 也比父亲节点多 1。</span></span><br><span class="line">  fa[root][<span class="number">0</span>] = fno;</span><br><span class="line">  dep[root] = dep[fa[root][<span class="number">0</span>]] + <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 初始化：其他的祖先节点：第 2^i 的祖先节点是第 2^(i-1) 的祖先节点的第</span></span><br><span class="line">  <span class="comment">// 2^(i-1) 的祖先节点。</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">31</span>; ++i) &#123;</span><br><span class="line">    fa[root][i] = fa[fa[root][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">    cost[root][i] = cost[fa[root][i - <span class="number">1</span>]][i - <span class="number">1</span>] + cost[root][i - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 遍历子节点来进行 dfs。</span></span><br><span class="line">  <span class="type">int</span> sz = v[root].<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sz; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (v[root][i] == fno) <span class="keyword">continue</span>;</span><br><span class="line">    cost[v[root][i]][<span class="number">0</span>] = w[root][i];</span><br><span class="line">    <span class="built_in">dfs</span>(v[root][i], root);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lca。用倍增算法算取 x 和 y 的 lca 节点。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 令 y 比 x 深。</span></span><br><span class="line">  <span class="keyword">if</span> (dep[x] &gt; dep[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">  <span class="comment">// 令 y 和 x 在一个深度。</span></span><br><span class="line">  <span class="type">int</span> tmp = dep[y] - dep[x], ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; tmp; ++j, tmp &gt;&gt;= <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> (tmp &amp; <span class="number">1</span>) ans += cost[y][j], y = fa[y][j];</span><br><span class="line">  <span class="comment">// 如果这个时候 y = x，那么 x，y 就都是它们自己的祖先。</span></span><br><span class="line">  <span class="keyword">if</span> (y == x) <span class="keyword">return</span> ans;</span><br><span class="line">  <span class="comment">// 不然的话，找到第一个不是它们祖先的两个点。</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">30</span>; j &gt;= <span class="number">0</span> &amp;&amp; y != x; --j) &#123;</span><br><span class="line">    <span class="keyword">if</span> (fa[x][j] != fa[y][j]) &#123;</span><br><span class="line">      ans += cost[x][j] + cost[y][j];</span><br><span class="line">      x = fa[x][j];</span><br><span class="line">      y = fa[y][j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回结果。</span></span><br><span class="line">  ans += cost[x][<span class="number">0</span>] + cost[y][<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化表示祖先的数组 fa，代价 cost 和深度 dep。</span></span><br><span class="line">  <span class="built_in">memset</span>(fa, <span class="number">0</span>, <span class="built_in">sizeof</span>(fa));</span><br><span class="line">  <span class="built_in">memset</span>(cost, <span class="number">0</span>, <span class="built_in">sizeof</span>(cost));</span><br><span class="line">  <span class="built_in">memset</span>(dep, <span class="number">0</span>, <span class="built_in">sizeof</span>(dep));</span><br><span class="line">  <span class="comment">// 读入树：节点数一共有 n 个。</span></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">    ++a, ++b;</span><br><span class="line">    v[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">    v[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">    w[a].<span class="built_in">push_back</span>(c);</span><br><span class="line">    w[b].<span class="built_in">push_back</span>(c);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 为了计算 lca 而使用 dfs。</span></span><br><span class="line">  <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="comment">// 查询 m 次，每一次查找两个节点的 lca 点。</span></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    ++a, ++b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">lca</span>(a, b));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="离线-·-Tarjan"><a href="#离线-·-Tarjan" class="headerlink" title="离线 · Tarjan"></a>离线 · Tarjan</h3><p><code>Tarjan 算法</code> 是一种 <code>离线算法</code>，需要使用 <code>并查集</code> 记录某个结点的祖先结点。做法如下：</p>
<ol>
<li>首先接受输入（邻接链表）、查询（存储在另一个邻接链表内）。查询边其实是虚拟加上去的边，为了方便，每次输入查询边的时候，将这个边及其反向边都加入到 <code>queryEdge</code> 数组里。</li>
<li>然后对其进行一次 DFS 遍历，同时使用 <code>visited</code> 数组进行记录某个结点是否被访问过、<code>parent</code>记录当前结点的父亲结点。</li>
<li>其中涉及到了 <code>回溯思想</code>，我们每次遍历到某个结点的时候，认为这个结点的根结点就是它本身。让以这个结点为根节点的 DFS 全部遍历完毕了以后，再将 <code>这个结点的根节点</code> 设置为 <code>这个结点的父一级结点</code>。</li>
<li>回溯的时候，如果以该节点为起点，<code>queryEdge</code> 查询边的另一个结点也恰好访问过了，则直接更新查询边的 LCA 结果。</li>
<li>最后输出结果。</li>
</ol>
<p>Tarjan 算法需要初始化并查集，所以预处理的时间复杂度为 $O(n)$，Tarjan 算法处理所有 $m$ 次询问的时间复杂度为 $O(n+m)$。但是 Tarjan 算法的常数比倍增算法大。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> toVertex, fromVertex;</span><br><span class="line">  <span class="type">int</span> next;</span><br><span class="line">  <span class="type">int</span> LCA;</span><br><span class="line">  <span class="built_in">Edge</span>() : <span class="built_in">toVertex</span>(<span class="number">-1</span>), <span class="built_in">fromVertex</span>(<span class="number">-1</span>), <span class="built_in">next</span>(<span class="number">-1</span>), <span class="built_in">LCA</span>(<span class="number">-1</span>)&#123;&#125;;</span><br><span class="line">  <span class="built_in">Edge</span>(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> n) : <span class="built_in">fromVertex</span>(u), <span class="built_in">toVertex</span>(v), <span class="built_in">next</span>(n), <span class="built_in">LCA</span>(<span class="number">-1</span>)&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> head[MAX], queryHead[MAX];</span><br><span class="line">Edge edge[MAX], queryEdge[MAX];</span><br><span class="line"><span class="type">int</span> parent[MAX], visited[MAX];</span><br><span class="line"><span class="type">int</span> vertexCount, edgeCount, queryCount;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= vertexCount; i++) &#123;</span><br><span class="line">    parent[i] = i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (parent[x] == x) &#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">find</span>(parent[x]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">  parent[u] = u;</span><br><span class="line">  visited[u] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = head[u]; i != <span class="number">-1</span>; i = edge[i].next) &#123;</span><br><span class="line">    Edge&amp; e = edge[i];</span><br><span class="line">    <span class="keyword">if</span> (!visited[e.toVertex]) &#123;</span><br><span class="line">      <span class="built_in">tarjan</span>(e.toVertex);</span><br><span class="line">      parent[e.toVertex] = u;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = queryHead[u]; i != <span class="number">-1</span>; i = queryEdge[i].next) &#123;</span><br><span class="line">    Edge&amp; e = queryEdge[i];</span><br><span class="line">    <span class="keyword">if</span> (visited[e.toVertex]) &#123;</span><br><span class="line">      queryEdge[i ^ <span class="number">1</span>].LCA = e.LCA = <span class="built_in">find</span>(e.toVertex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(head, <span class="number">0xff</span>, <span class="built_in">sizeof</span>(head));</span><br><span class="line">  <span class="built_in">memset</span>(queryHead, <span class="number">0xff</span>, <span class="built_in">sizeof</span>(queryHead));</span><br><span class="line"></span><br><span class="line">  cin &gt;&gt; vertexCount &gt;&gt; edgeCount &gt;&gt; queryCount;</span><br><span class="line">  <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; edgeCount; i++) &#123;</span><br><span class="line">    <span class="type">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; start &gt;&gt; end;</span><br><span class="line"></span><br><span class="line">    edge[count] = <span class="built_in">Edge</span>(start, end, head[start]);</span><br><span class="line">    head[start] = count;</span><br><span class="line">    count++;</span><br><span class="line"></span><br><span class="line">    edge[count] = <span class="built_in">Edge</span>(end, start, head[end]);</span><br><span class="line">    head[end] = count;</span><br><span class="line">    count++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; queryCount; i++) &#123;</span><br><span class="line">    <span class="type">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; start &gt;&gt; end;</span><br><span class="line"></span><br><span class="line">    queryEdge[count] = <span class="built_in">Edge</span>(start, end, queryHead[start]);</span><br><span class="line">    queryHead[start] = count;</span><br><span class="line">    count++;</span><br><span class="line"></span><br><span class="line">    queryEdge[count] = <span class="built_in">Edge</span>(end, start, queryHead[end]);</span><br><span class="line">    queryHead[end] = count;</span><br><span class="line">    count++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">init</span>();</span><br><span class="line">  <span class="built_in">tarjan</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; queryCount; i++) &#123;</span><br><span class="line">    Edge&amp; e = queryEdge[i * <span class="number">2</span>];</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; e.fromVertex &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; e.toVertex &lt;&lt; <span class="string">&quot;) &quot;</span> &lt;&lt; e.LCA &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




































      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/09/2021-5-9-shu/" data-id="clz6fe7hw00260loxdqvk5uyo" data-title="树" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%A0%91/" rel="tag">树</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-2021-5-2-DP" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/02/2021-5-2-dp/" class="article-date">
  <time class="dt-published" datetime="2021-05-02T07:28:00.000Z" itemprop="datePublished">2021-05-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/ACM/">ACM</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/02/2021-5-2-dp/">DP</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h1><h2 id="基础-DP"><a href="#基础-DP" class="headerlink" title="基础 DP"></a>基础 DP</h2><h3 id="最长公共子串"><a href="#最长公共子串" class="headerlink" title="最长公共子串"></a>最长公共子串</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>连续</li>
</ul>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>动态转移方程</p>
<p><code>if (a[i] == b[j]) dp[i][j] = dp[i-1][j-1] + 1;</code></p>
<p><code>else dp[i][j] = 0;</code></p>
<h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#define _CRTSECURE_NOWARNINGS</span><br><span class="line">#pragma warning(disable:4996)</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;cctype&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;list&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define INF 0x7fffffff</span><br><span class="line"></span><br><span class="line">int n, m;</span><br><span class="line">char a[10001], b[10001];</span><br><span class="line">int dp[10001][10001];</span><br><span class="line">int maxn;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	scanf(&quot;%s&quot;, a + 1);</span><br><span class="line">	scanf(&quot;%s&quot;, b + 1);</span><br><span class="line">	int n = strlen(a + 1);</span><br><span class="line">	int m = strlen(b + 1);</span><br><span class="line">	for (int i = 1; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		for (int j = 1; j &lt;= m; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			if (a[i] == b[j]) dp[i][j] = dp[i - 1][j - 1] + 1;</span><br><span class="line">			maxn = max(maxn, dp[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;%d&quot;, maxn);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h3><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul>
<li>可以不连续</li>
</ul>
<p>动态转移方程</p>
<p><code>if (a[i] == b[j]) dp[i][j] = dp[i-1][j-1] + 1;</code><br><code>dp[i][j] = max(dp[i][j], dp[i-1][j], dp[i][j-1]);</code></p>
<h4 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRTSECURE_NOWARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:4996)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[<span class="number">10001</span>], b[<span class="number">10001</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">10001</span>][<span class="number">10001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x &gt; y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max1</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> t[<span class="number">4</span>] = &#123; <span class="number">0</span>, x, y, z &#125;;</span><br><span class="line">	<span class="built_in">sort</span>(t + <span class="number">1</span>, t + <span class="number">4</span>, cmp);</span><br><span class="line">	<span class="keyword">return</span> t[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;b[i]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (a[i] == b[j]) dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">			dp[i][j] = <span class="built_in">max1</span>(dp[i][j], dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, dp[n][m]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="01-背包"><a href="#01-背包" class="headerlink" title="01 背包"></a>01 背包</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>已知条件有第 i 个物品的重量 w[i]，价值 v[i]，以及背包的总容量 W。</p>
<h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><p>有多样物品</p>
<ul>
<li>每样物品只有一件</li>
<li>每件物品只有 <code>取</code> 或 <code>不取</code> 两种状态</li>
</ul>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>dp[i][j]：在只能取前 i 件物品的情况下，容量为 j 的背包能取的最大价值</p>
<p>假设当前已经处理好了前 i - 1 个物品的所有状态，那么对于第 i 个物品，有取或不取两种选择</p>
<ul>
<li>当其不放入背包时，背包的剩余容量不变，背包中物品的总价值也不变，故这种情况的最大价值为 f[i-1][j]</li>
<li>当其放入背包时，背包的剩余容量会减小 ，背包中物品的总价值会增大 ，故这种情况的最大价值为 f[i-1][j-w[i]] + v[i]。</li>
</ul>
<p>动态转移方程：<code>dp[i][j] = max(dp[i-1][j], dp[i-1][j - w[i]] + v[i])</code></p>
<h3 id="模板-2"><a href="#模板-2" class="headerlink" title="模板"></a>模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j = w[i]; j &lt;= W; j++)</span><br><span class="line">    dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j - w[i]] + v[i]);</span><br></pre></td></tr></table></figure>



<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>可以发现，第 i 次循环时的 dp 数组只受第 i - 1 层的影响，因此可以去掉第一维</p>
<p>但是若 j 从前往后便利，则会在同一层将之后需要用到的数据覆盖掉，相当于可以多次将物品 i 多次放入背包（这就是完全背包的解法），因此要从后往前遍历。</p>
<p>动态转移方程：<code>dp[j] = max(dp[j], dp[j - w[i]] + v[i])</code></p>
<h3 id="模板-3"><a href="#模板-3" class="headerlink" title="模板"></a>模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j = W; j &gt;= w[i]; j--)</span><br><span class="line">    dp[j] = <span class="built_in">max</span>(dp[j], dp[j - w[i]] + v[i]);</span><br></pre></td></tr></table></figure>





<h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>已知条件有第 i 个物品的重量 w[i]，价值 v[i]，以及背包的总容量 W。</p>
<h3 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h3><p>有多样物品</p>
<ul>
<li>每样物品有无数件</li>
<li>每件物品只有 <code>取</code> 或 <code>不取</code> 两种状态</li>
</ul>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>dp[i][j]：在只能取前 i 件物品的情况下，容量为 j 的背包能取的最大价值</p>
<p>遍历时对于 <code>取</code> 的状态，在同一层中计算，因此 j 将遍历到第 i 件物品的倍数，相当于对这件物品多次取</p>
<p>若 j 从后往前遍历，会出现同一层中需要用到的数据还未计算的情况，因此需从前往后遍历。</p>
<p>动态转移方程：<code>dp[i][j] = max(dp[i-1][j], dp[i][j - w[i]] + v[i])</code></p>
<h3 id="模板-4"><a href="#模板-4" class="headerlink" title="模板"></a>模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dpor</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">  <span class="built_in">dpor</span> (<span class="type">int</span> j = w[i]; j &lt;= W; j++)</span><br><span class="line">    dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i][j - w[i]] + v[i]);</span><br></pre></td></tr></table></figure>



<h3 id="优化-1"><a href="#优化-1" class="headerlink" title="优化"></a>优化</h3><p>跟 01 背包的优化思路一样，可以去除一层数组</p>
<p><code>dp[j] = max(dp[j], dp[j - w[i]] + v[i])</code></p>
<h3 id="模板-5"><a href="#模板-5" class="headerlink" title="模板"></a>模板</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dpor (int i = 1; i &lt;= n; i++)</span><br><span class="line">  dpor (int j = w[i]; j &lt;= W; j++)</span><br><span class="line">    dp[j] = max(dp[j], dp[j - w[i]] + v[i])</span><br></pre></td></tr></table></figure>





<h2 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p>已知条件有第 i 个物品的重量 w[i]，价值 v[i]，以及背包的总容量 W。</p>
<h3 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h3><p>有多样物品</p>
<ul>
<li>每样物品有 <code>1 件</code> 或 <code>k 件</code></li>
<li>每件物品只有 <code>取</code> 或 <code>不取</code> 两种状态</li>
</ul>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>把 “每种物品有 k<sub>i</sub> 件” 等价转换为 “有 k<sub>i</sub> 个相同的物品，每个物品只有一件”。这样就转换成了一个 01 背包模型，套用上文所述的方法就可已解决。</p>
<h3 id="优化-2"><a href="#优化-2" class="headerlink" title="优化"></a>优化</h3><h4 id="二进制分组优化"><a href="#二进制分组优化" class="headerlink" title="二进制分组优化"></a>二进制分组优化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> c = <span class="number">1</span>, p, h, k;</span><br><span class="line">  <span class="built_in">scanf</span> (<span class="string">&quot;%d%d%d&quot;</span>, &amp;p, &amp;h, &amp;k);</span><br><span class="line">  <span class="keyword">while</span> (k - c &gt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    k -= c;</span><br><span class="line">    list[++index].w = c * p;</span><br><span class="line">    list[index].v = c * h;</span><br><span class="line">    c *= <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  list[++index].w = p * k;</span><br><span class="line">  list[index].v = h * k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="混合背包"><a href="#混合背包" class="headerlink" title="混合背包"></a>混合背包</h2><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h3><p>已知条件有第 i 个物品的重量 w[i]，价值 v[i]，以及背包的总容量 W。</p>
<h3 id="特点-5"><a href="#特点-5" class="headerlink" title="特点"></a>特点</h3><p>有多样物品</p>
<ul>
<li>每样物品有 <code>1 件</code> &#x2F; <code>k 件</code> 或 <code>无数件</code></li>
<li>每件物品只有 <code>取</code> 或 <code>不取</code> 两种状态</li>
</ul>
<h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>将每一类背包问题分别求解</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (循环物品种类)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (是 <span class="number">01</span> 背包)</span><br><span class="line">    套用 <span class="number">01</span> 背包代码;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (是完全背包)</span><br><span class="line">    套用完全背包代码;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (是多重背包)</span><br><span class="line">    套用多重背包代码;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="二维费用背包"><a href="#二维费用背包" class="headerlink" title="二维费用背包"></a>二维费用背包</h2><h3 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h3><p>已知条件有第 i 个物品的重量 w[i]，耗时 t[i]，价值 v[i]，以及背包的总容量 W。</p>
<h3 id="特点-6"><a href="#特点-6" class="headerlink" title="特点"></a>特点</h3><p>有多样物品</p>
<ul>
<li>每样物品只有 <code>1 件</code></li>
<li>每件物品只有 <code>取</code> 或 <code>不取</code> 两种状态</li>
</ul>
<h3 id="模板-6"><a href="#模板-6" class="headerlink" title="模板"></a>模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k++)	<span class="comment">//对物品进行枚举</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = m; i &gt;= mi; i--)	<span class="comment">// 对经费进行一层枚举</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = t; j &gt;= ti; j--)	<span class="comment">// 对时间进行一层枚举</span></span><br><span class="line">      dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i - mi][j - ti] + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>





<h2 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h2><h3 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h3><p>所谓分组背包，就是将物品分组，每组的物品 <strong>相互冲突</strong> ，最多只能选一个物品放进去。</p>
<h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>从「在所有物品中选择一件」变成了「从当前组中选择一件」，于是就对每一组进行一次 01 背包就可以了。</p>
<p>可以将 t[k][i] 表示第 k 组的第 i 件物品的编号是多少，再用 cnt[k] 表示第 k 组物品有多少个。</p>
<h3 id="模板-7"><a href="#模板-7" class="headerlink" title="模板"></a>模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= ts; k++)          <span class="comment">// 循环每一组</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = m; i &gt;= <span class="number">0</span>; i--)         <span class="comment">// 循环背包容量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= cnt[k]; j++)  <span class="comment">// 循环该组的每一个物品</span></span><br><span class="line">      <span class="keyword">if</span> (i &gt;= w[t[k][j]])</span><br><span class="line">        dp[i] = <span class="built_in">max</span>(dp[i], dp[i - w[t[k][j]]] + c[t[k][j]]);  <span class="comment">// 像0-1背包一样状态转移</span></span><br></pre></td></tr></table></figure>

<p><strong>注意循环顺序</strong></p>
<h2 id="有依赖的背包"><a href="#有依赖的背包" class="headerlink" title="有依赖的背包"></a>有依赖的背包</h2><h3 id="简介-6"><a href="#简介-6" class="headerlink" title="简介"></a>简介</h3><p>如果选第 i 件物品，就必须选第 j 件物品，保证不会循环引用，一部分题目甚至会出现多叉树的引用形式。为了方便，就称不依赖于别的物品的物品称为「主件」，依赖于某主件的物品称为「附件」。</p>
<h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><p>对于包含一个主件和若干个附件的集合有以下可能性：仅选择主件，选择主件后再选择一个附件，选择主件后再选择两个附件……需要将以上可能性的容量和价值转换成一件件物品。因为这几种可能性只能选一种，所以可以将这看成分组背包。</p>
<p>如果是多叉树的集合，则要先算子节点的集合，最后算父节点的集合。</p>
<h2 id="区间DP"><a href="#区间DP" class="headerlink" title="区间DP"></a>区间DP</h2><h3 id="简介-7"><a href="#简介-7" class="headerlink" title="简介"></a>简介</h3><p>区间类动态规划是线性动态规划的扩展，它在分阶段地划分问题时，与阶段中元素出现的顺序和由前一阶段的哪些元素合并而来有很大的关系。令状态 f(i, j) 表示将下标位置 i 到 j 的所有元素合并能获得的价值的最大值，那么 <code>f(i, j) = max &#123; f(i, k) + f(k + 1, j) + cost &#125;</code>，cost 为将这两组元素合并起来的代价。</p>
<h3 id="特点-7"><a href="#特点-7" class="headerlink" title="特点"></a>特点</h3><ul>
<li><strong>合并</strong>：即将两个或多个部分进行整合，当然也可以反过来；</li>
<li><strong>特征</strong>：能将问题分解为能两两合并的形式；</li>
<li><strong>求解</strong>：对整个问题设最优值，枚举合并点，将问题分解为左右两个部分，最后合并两个部分的最优值得到原问题的最优值。</li>
</ul>
<h3 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h3><p>既然让我求解在一个区间上的最优解，那么我把这个区间分割成一个个小区间，求解每个小区间的最优解，再合并小区间得到大区间即可。所以在代码实现上，我可以枚举区间长度 len 为每次分割成的小区间长度（由短到长不断合并），内层枚举该长度下可以的起点，自然终点也就明了了。然后在这个起点终点之间枚举分割点，求解这段小区间在某个分割点下的最优解。</p>
<h3 id="模板-8"><a href="#模板-8" class="headerlink" title="模板"></a>模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> len = <span class="number">1</span>; len &lt;= n; len++)	<span class="comment">//枚举长度</span></span><br><span class="line">&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j + len &lt;= n + <span class="number">1</span>; j++)	<span class="comment">//枚举起点，ends &lt;= n</span></span><br><span class="line">		&#123;</span><br><span class="line">				<span class="type">int</span> ends = j + len - <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> i = j; i &lt; ends; i++)	<span class="comment">//枚举分割点，更新小区间最优解</span></span><br><span class="line">				&#123;</span><br><span class="line">					dp[j][ends] = <span class="built_in">min</span>(dp[j][ends], dp[j][i] + dp[i<span class="number">+1</span>][ends] + something);</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="朴素区间-DP-O-n3"><a href="#朴素区间-DP-O-n3" class="headerlink" title="朴素区间 DP O(n3)"></a>朴素区间 DP O(n<sup>3</sup>)</h3><h4 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h4><p>N  堆石子摆成一条线。现要将石子有次序地合并成一堆。规定每次只能选相邻的 2 堆石子合并成新的一堆，并将新的一堆石子数记为该次合并的代价。计算将 N 堆石子合并成一堆的最小代价。</p>
<h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><p>数据的第 1 行是正整数 N，表示有 N 堆石子。第 2 行有 N 个整数，第 i 个整数 a<sub>i</sub> 表示第 i 堆石子的个数。</p>
<h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><p>输出共 1 行：最小得分。</p>
<h4 id="Example-Input"><a href="#Example-Input" class="headerlink" title="Example Input"></a>Example Input</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1 2 3 4</span><br></pre></td></tr></table></figure>



<h4 id="Example-Output"><a href="#Example-Output" class="headerlink" title="Example Output"></a>Example Output</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">19</span><br></pre></td></tr></table></figure>



<h4 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h4><p>1 2 3 4 (0) -&gt; 3 3 4 (3) -&gt; 6 4 (9) -&gt; 10 (19)</p>
<h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>f[x][y]：从 x 到 y 的最小得分</p>
<p>sum[x][y]：从 x 到 y 的重量和</p>
<p>转移方程：<code>f[i][j] = min(f[i][j], f[i][k] + f[k + 1][j] + sum[i][ends]);</code></p>
<p>其中 sum[x][y] 可以用前缀和数组 arr[] 代替，sum[x][y] &#x3D; arr[y] - arr[x - 1]</p>
<h4 id="Accepted-Code"><a href="#Accepted-Code" class="headerlink" title="Accepted Code"></a>Accepted Code</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRTSECURE_NOWARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:4996)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, a[<span class="number">101</span>], arr[<span class="number">101</span>];</span><br><span class="line"><span class="type">int</span> f[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        arr[i] = arr[i<span class="number">-1</span>] + a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> p = <span class="number">1</span>; p &lt; n; p++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = i + p; i &lt; n &amp;&amp; j &lt;= n; i++, j = i + p)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j] = INF;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt; j; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                f[i][j] = <span class="built_in">min</span>(f[i][j], f[i][k] + f[k<span class="number">+1</span>][j] + arr[j] - arr[i<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%d&quot;</span>, f[<span class="number">1</span>][n]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="线性变环状"><a href="#线性变环状" class="headerlink" title="线性变环状"></a>线性变环状</h3><h4 id="NOI-1995-石子合并"><a href="#NOI-1995-石子合并" class="headerlink" title="NOI 1995 石子合并"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1880">NOI 1995 石子合并</a></h4><h4 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h4><p>在一个圆形操场的四周摆放 N 堆石子，现要将石子有次序地合并成一堆。规定每次只能选相邻的 2 堆合并成新的一堆，并将新的一堆的石子数，记为该次合并的得分。试设计出一个算法，计算出将 N 堆石子合并成 1 堆的最小得分和最大得分。</p>
<h4 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h4><p>数据的第 1 行是正整数 N，表示有 N 堆石子。第 2 行有 N 个整数，第 i 个整数 a<sub>i</sub> 表示第 i 堆石子的个数。</p>
<h4 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h4><p>输出共 2 行，第 1 行为最小得分，第 2 行为最大得分。</p>
<h4 id="Example-Input-1"><a href="#Example-Input-1" class="headerlink" title="Example Input"></a>Example Input</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">4 5 9 4</span><br></pre></td></tr></table></figure>



<h4 id="Example-Output-1"><a href="#Example-Output-1" class="headerlink" title="Example Output"></a>Example Output</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">43</span><br><span class="line">54</span><br></pre></td></tr></table></figure>



<h4 id="Hint-1"><a href="#Hint-1" class="headerlink" title="Hint"></a>Hint</h4><p>1 ≤ N ≤ 100，0 ≤ a<sub>i</sub> ≤ 200 ≤ a<sub>i</sub> ≤ 20。</p>
<h4 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h4><p>f1[x][y]：从 x 到 y 的最小得分</p>
<p>sum[x][y]：从 x 到 y 的重量和</p>
<p>转移方程：<code>f1[i][j] = min(f1[i][j], f1[i][k] + f1[k + 1][j] + sum[i][ends]);</code></p>
<p>其中 sum[x][y] 可以用前缀和数组 arr[] 代替 sum[x][y] &#x3D; arr[y] - arr[x - 1]</p>
<h4 id="Accepted-Code-1"><a href="#Accepted-Code-1" class="headerlink" title="Accepted Code"></a>Accepted Code</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRTSECURE_NOWARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:4996)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, minl, maxl, f1[<span class="number">300</span>][<span class="number">300</span>], f2[<span class="number">300</span>][<span class="number">300</span>], num[<span class="number">300</span>];</span><br><span class="line"><span class="type">int</span> s[<span class="number">300</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">d</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span>  <span class="comment">//转移方程：f[i][j] = max(f[i][k]+f[k+1][j]+d[i][j];</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s[j] - s[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n + n; i++) <span class="comment">//因为是一个环，所以需要开到两倍再枚举分界线，最后肯定是最大的</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num[i]);</span><br><span class="line">        num[i + n] = num[i];</span><br><span class="line">        s[i] = s[i - <span class="number">1</span>] + num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> p = <span class="number">1</span>; p &lt; n; p++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>,j = i + p; (j &lt; n + n) &amp;&amp; (i &lt; n + n); i++, j = i + p)</span><br><span class="line">        &#123;</span><br><span class="line">            f2[i][j] = INF;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = i; k &lt; j; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                f1[i][j] = <span class="built_in">max</span>(f1[i][j], f1[i][k] + f1[k + <span class="number">1</span>][j] + <span class="built_in">d</span>(i, j));</span><br><span class="line">                f2[i][j] = <span class="built_in">min</span>(f2[i][j], f2[i][k] + f2[k + <span class="number">1</span>][j] + <span class="built_in">d</span>(i, j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    minl = INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        maxl = <span class="built_in">max</span>(maxl, f1[i][i + n - <span class="number">1</span>]);</span><br><span class="line">        minl = <span class="built_in">min</span>(minl, f2[i][i + n - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n%d&quot;</span>, minl, maxl);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="四边形优化-O-n2"><a href="#四边形优化-O-n2" class="headerlink" title="四边形优化 O(n2)"></a>四边形优化 O(n<sup>2</sup>)</h3><h4 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h4><p>在查找最优分割点的时候，我们浪费了大量时间。那么我们可以把最优分割点保存下来，在查找的时候利用保存的最优分割点来优化查找过程。</p>
<h4 id="四边形不等式优化"><a href="#四边形不等式优化" class="headerlink" title="四边形不等式优化"></a>四边形不等式优化</h4><ol>
<li>功能：用来寻找，s[i][j] （i ~ j 的最优分割点）与其他分割点的关系</li>
<li>不等式内容：如果某东西满足 a &lt; b &lt;&#x3D; c &lt; d 且f[a][c] + f[b][d] &lt;&#x3D; f[a][d] + f[b][c]，则说这个东西满足四边形不等式。简而言之：交叉小于包含！</li>
<li>结论关系：s[i][j-1] &lt;&#x3D; s[i][j] &lt;&#x3D; s[i+1][j] </li>
<li>证明过程：<ol>
<li>证明 w 满足四边形不等式，这里 w 是 m 的附属量，形如 m[i, j] &#x3D; opt{ m[i, k] + m[k, j] + w[i, j] }，此时大多要先证明 w 满足条件才能进一步证明 m 满足条件</li>
<li>证明 m 满足四边形不等式</li>
<li>证明 s[i, j-1] ≤ s[i, j] ≤ s[i+1, j]</li>
</ol>
</li>
</ol>
<h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRTSECURE_NOWARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:4996)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">2005</span>][<span class="number">2005</span>];</span><br><span class="line"><span class="type">int</span> sum[<span class="number">2005</span>];</span><br><span class="line"><span class="type">int</span> relation[<span class="number">2005</span>][<span class="number">2005</span>];</span><br><span class="line"><span class="type">int</span> num[<span class="number">2005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">memset</span>(sum, <span class="number">0</span>, <span class="built_in">sizeof</span>(sum));</span><br><span class="line">    <span class="built_in">memset</span>(dp, INF, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num[i]);</span><br><span class="line">        dp[i][i] = <span class="number">0</span>;</span><br><span class="line">        relation[i][i] = i;</span><br><span class="line">        sum[i] = sum[i<span class="number">-1</span>] + num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum[i+n] = sum[i+n<span class="number">-1</span>] + num[i];</span><br><span class="line">        relation[i+n][i+n] = i + n; <span class="comment">//分割点初始化</span></span><br><span class="line">        dp[i+n][i+n] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> len = <span class="number">1</span>; len &lt;= n; len++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j + len &lt;= <span class="number">2</span> * n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> ends = j + len - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = relation[j][ends<span class="number">-1</span>]; k &lt;= relation[j<span class="number">+1</span>][ends]; k++) <span class="comment">//k的范围</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[j][ends] &gt; dp[j][k] + dp[k<span class="number">+1</span>][ends] + sum[ends] - sum[j<span class="number">-1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[j][ends] = dp[j][k] + dp[k<span class="number">+1</span>][ends] + sum[ends] - sum[j<span class="number">-1</span>];</span><br><span class="line">                    relation[j][ends] = k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, dp[i][i+n<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="POJ-2955-Brackets-括号匹配"><a href="#POJ-2955-Brackets-括号匹配" class="headerlink" title="POJ 2955 Brackets 括号匹配"></a><a target="_blank" rel="noopener" href="http://poj.org/problem?id=2955">POJ 2955 Brackets 括号匹配</a></h3><h4 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h4><p>We give the following inductive definition of a “regular brackets” sequence:the empty sequence is a regular brackets sequence,if s is a regular brackets sequence, then (s) and [s] are regular brackets sequences, andif a and b are regular brackets sequences, then ab is a regular brackets sequence.no other sequence is a regular brackets sequenceFor instance, all of the following character sequences are regular brackets sequences: <code>()</code>, <code>[]</code>, <code>(())</code>, <code>()[]</code>, <code>()[()]</code> while the following character sequences are not: <code>(</code>, <code>]</code>, <code>)(</code>, <code>([)]</code>, <code>([(]</code> Given a brackets sequence of characters a<sub>1</sub>a<sub>2</sub> … a<sub>n</sub>, your goal is to find the length of the longest regular brackets sequence that is a subsequence of s. That is, you wish to find the largest m such that for indices i<sub>1</sub>, i<sub>2</sub>, …, im where 1 ≤ i<sub>1</sub> &lt; i<sub>2</sub> &lt; … &lt; i<sub>m</sub> ≤ n, a<sub>i1</sub>a<sub>i2</sub> … a<sub>im</sub> is a regular brackets sequence.Given the initial sequence <code>([([]])]</code>, the longest regular brackets subsequence is <code>[([])]</code>.</p>
<h4 id="Input-2"><a href="#Input-2" class="headerlink" title="Input"></a>Input</h4><p>The input test file will contain multiple test cases. Each input test case consists of a single line containing only the characters (, ), [, and ]; each input test will have length between 1 and 100, inclusive. The end-of-file is marked by a line containing the word “end” and should not be processed.</p>
<h4 id="Output-2"><a href="#Output-2" class="headerlink" title="Output"></a>Output</h4><p>For each input case, the program should print the length of the longest possible regular brackets subsequence on a single line.</p>
<h4 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">((()))</span><br><span class="line">()()()</span><br><span class="line">([]])</span><br><span class="line">)[)(</span><br><span class="line">([][][)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>



<h4 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">6</span><br><span class="line">4</span><br><span class="line">0</span><br><span class="line">6</span><br></pre></td></tr></table></figure>



<h4 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h4><p>题意：给出一个的只有 ‘(‘, ‘)’, ‘[‘, ‘]’ 四种括号组成的字符串，求最多有多少个括号满足题目里所描述的完全匹配。</p>
<p>动态转移方程：如果 s[i] 与 s[j] 匹配：<code>dp[i][j] = dp[i+1][j-1] + 2</code></p>
<p>再遍历中间节点：<code>dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j])</code></p>
<h4 id="Accpted-Code"><a href="#Accpted-Code" class="headerlink" title="Accpted Code"></a>Accpted Code</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRTSECURE_NOWARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:4996)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> s[<span class="number">110</span>];</span><br><span class="line"><span class="type">int</span> f[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span> (s, <span class="number">0</span>, <span class="built_in">sizeof</span> (s));</span><br><span class="line">        <span class="built_in">memset</span> (f, <span class="number">0</span>, <span class="built_in">sizeof</span> (f));</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">1</span>] == <span class="string">&#x27;e&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        s[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">strlen</span> (s<span class="number">+1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> p = <span class="number">2</span>; p &lt;= l; p++)    <span class="comment">//区间大小：2 ~ l</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = i + p - <span class="number">1</span>; j &lt;= l; i++, j = i + p - <span class="number">1</span>)  <span class="comment">//区间：i ~ j</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> ((s[i] == <span class="string">&#x27;(&#x27;</span> &amp;&amp; s[j] == <span class="string">&#x27;)&#x27;</span>) || (s[i] == <span class="string">&#x27;[&#x27;</span> &amp;&amp; s[j] == <span class="string">&#x27;]&#x27;</span>))</span><br><span class="line">                    f[i][j] = f[i<span class="number">+1</span>][j<span class="number">-1</span>] + <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt; j; k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    f[i][j] = <span class="built_in">max</span>(f[i][j], f[i][k] + f[k<span class="number">+1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, f[<span class="number">1</span>][l]);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="POJ-1651-Multiplication-Puzzle-抽卡片"><a href="#POJ-1651-Multiplication-Puzzle-抽卡片" class="headerlink" title="POJ 1651 Multiplication Puzzle 抽卡片"></a><a target="_blank" rel="noopener" href="http://poj.org/problem?id=1651">POJ 1651 Multiplication Puzzle 抽卡片</a></h3><h4 id="Description-3"><a href="#Description-3" class="headerlink" title="Description"></a>Description</h4><p>The multiplication puzzle is played with a row of cards, each containing a single positive integer. During the move player takes one card out of the row and scores the number of points equal to the product of the number on the card taken and the numbers on the cards on the left and on the right of it. It is not allowed to take out the first and the last card in the row. After the final move, only two cards are left in the row. </p>
<p>The goal is to take cards in such order as to minimize the total number of scored points. </p>
<p>For example, if cards in the row contain numbers 10 1 50 20 5, player might take a card with 1, then 20 and 50, scoring<br>10 * 1 * 50 + 50 * 20 * 5 + 10 * 50 * 5 &#x3D; 500 + 5000 + 2500 &#x3D; 8000<br>If he would take the cards in the opposite order, i.e. 50, then 20, then 1, the score would be<br>1 * 50 * 20 + 1 * 20 * 5 + 10 * 1 * 5 &#x3D; 1000 + 100 + 50 &#x3D; 1150.</p>
<h4 id="Input-3"><a href="#Input-3" class="headerlink" title="Input"></a>Input</h4><p>The first line of the input contains the number of cards N (3 &lt;&#x3D; N &lt;&#x3D; 100). The second line contains N integers in the range from 1 to 100, separated by spaces.</p>
<h4 id="Output-3"><a href="#Output-3" class="headerlink" title="Output"></a>Output</h4><p>Output must contain a single integer - the minimal score.</p>
<h4 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input"></a>Sample Input</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">10 1 50 50 20 5</span><br></pre></td></tr></table></figure>

<h4 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output"></a>Sample Output</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3650</span><br></pre></td></tr></table></figure>



<h4 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h4><p>题意：给出 n 个数字，要求不能删除两端点的数字，然后删除其他数字的代价是该数字和左右相邻数字的乘积，问把数字（除端点）删完后的最小总代价。</p>
<p>dp[i][j]：抽出 i ~ (j - 1) 卡片的最小值</p>
<p>动态转移方程：<code>dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + a[i-1] * a[k] * a[j])</code></p>
<h4 id="Accepted-Code-2"><a href="#Accepted-Code-2" class="headerlink" title="Accepted Code"></a>Accepted Code</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRTSECURE_NOWARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:4996)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[<span class="number">101</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> p = <span class="number">1</span>; p &lt; n; p++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>, j = i + p; j &lt;= n; i++, j = i + p)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][j] = INF;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt; j; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i][k] + dp[k<span class="number">+1</span>][j] + a[i<span class="number">-1</span>] * a[k] * a[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%d&quot;</span>, dp[<span class="number">2</span>][n]);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="HDU-4632-Palindrome-subsequence-最长回文子串"><a href="#HDU-4632-Palindrome-subsequence-最长回文子串" class="headerlink" title="HDU 4632 Palindrome subsequence 最长回文子串"></a><a target="_blank" rel="noopener" href="http://acm.hdu.edu.cn/showproblem.php?pid=4632">HDU 4632 Palindrome subsequence 最长回文子串</a></h3><h4 id="Description-4"><a href="#Description-4" class="headerlink" title="Description"></a>Description</h4><p>In mathematics, a subsequence is a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements. For example, the sequence &lt;A, B, D&gt; is a subsequence of &lt;A, B, C, D, E, F&gt;.<br><a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Subsequence">http://en.wikipedia.org/wiki/Subsequence</a></p>
<p>Given a string S, your task is to find out how many different subsequence of S is palindrome. Note that for any two subsequence X &#x3D; &lt;S<sub>x1</sub>, S<sub>x2</sub>, …, S<sub>xk</sub>&gt; and Y &#x3D; &lt;S<sub>y1</sub>, S<sub>y2</sub>, …, S<sub>yk</sub>&gt; , if there exist an integer i (1 &lt;&#x3D; i &lt;&#x3D; k) such that xi !&#x3D; yi, the subsequence X and Y should be consider different even if S<sub>xi</sub> &#x3D; S<sub>yi</sub>. Also two subsequences with different length should be considered different.</p>
<h4 id="Input-4"><a href="#Input-4" class="headerlink" title="Input"></a>Input</h4><p>The first line contains only one integer T (T &lt;&#x3D; 50), which is the number of test cases. Each test case contains a string S, the length of S is not greater than 1000 and only contains lowercase letters.</p>
<h4 id="Output-4"><a href="#Output-4" class="headerlink" title="Output"></a>Output</h4><p>For each test case, output the case number first, then output the number of different subsequence of the given string, the answer should be module 10007.</p>
<h4 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input"></a>Sample Input</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">a</span><br><span class="line">aaaaa</span><br><span class="line">goodafternooneveryone</span><br><span class="line">welcometoooxxourproblems</span><br></pre></td></tr></table></figure>

<h4 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output"></a>Sample Output</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Case 1: 1</span><br><span class="line">Case 2: 31</span><br><span class="line">Case 3: 421</span><br><span class="line">Case 4: 960</span><br></pre></td></tr></table></figure>



<h4 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h4><p>题意：给出一个字符串，求出其最多的可构成的回文字串（不要求连续），注：这里不同的回文字串只要求位置不同即可视为不同，如：aaaaa 的最多回文子串数目是 31.</p>
<p>dp[i][j]：i ~ j 构成的最多回文串个数</p>
<p>动态转移方程：</p>
<ul>
<li>根据容斥定理：dp[i+1][j] 并 dp[i][j-1] &#x3D; dp[i+1][j] + dp[i][j-1] - dp[i+1][j-1]</li>
<li>如果 s[i] &#x3D;&#x3D; s[j]<ul>
<li>两端单独可以构成回文子序列 + 1</li>
<li>与dp[i+1][j], dp[i][j-1], dp[i+1][j-1] 中的每个回文序列可以构成新的回文序列 + dp[i+1][j-1]</li>
</ul>
</li>
</ul>
<p>注：这里因为容斥时有减法，所以要先加上模再取模，否则会出现负数</p>
<p><code>dp[i][j] = (dp[i+1][j] + dp[i][j-1] - dp[i+1][j-1] + 10007) % 10007;</code></p>
<p><code>if (s[i] == s[j]) dp[i][j] = (dp[i][j] + dp[i+1][j-1] + 1) % 10007;</code></p>
<h4 id="Accepted-Code-3"><a href="#Accepted-Code-3" class="headerlink" title="Accepted Code"></a>Accepted Code</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRTSECURE_NOWARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:4996)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> T;</span><br><span class="line"><span class="type">char</span> s[<span class="number">1010</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> t = <span class="number">1</span>; t &lt;= T; t++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="built_in">sizeof</span> (s));</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span> (dp));</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= l; i++) dp[i][i] = <span class="number">1</span>;  <span class="comment">//自己单独构成一个回文</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> p = <span class="number">1</span>; p &lt;= l; p++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = i + p - <span class="number">1</span>; j &lt;= l; i++, j = i + p - <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = (dp[i<span class="number">+1</span>][j] + dp[i][j<span class="number">-1</span>] - dp[i<span class="number">+1</span>][j<span class="number">-1</span>] + <span class="number">10007</span>) % <span class="number">10007</span>;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j]) dp[i][j] = (dp[i][j] + dp[i<span class="number">+1</span>][j<span class="number">-1</span>] + <span class="number">1</span>) % <span class="number">10007</span>; <span class="comment">//如果两端相等，dp[i][j] = 原来的 + 两端与中间每一个回文也可以构成回文（dp[i+1][j-1]) + 两端单独构成一个回文（1）</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;Case %d: %d\n&quot;</span>, t, dp[<span class="number">1</span>][l]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h1 id="DAG-上的-DP"><a href="#DAG-上的-DP" class="headerlink" title="DAG 上的 DP"></a>DAG 上的 DP</h1><h3 id="简介-8"><a href="#简介-8" class="headerlink" title="简介"></a>简介</h3><p>DAG 即 <strong>有向无环图</strong>，一些实际问题中的二元关系都可使用 DAG 来建模，如转化为 DAG 上的最长路、最短路和路径计数问题。</p>
<h3 id="The-Tower-of-Babylon"><a href="#The-Tower-of-Babylon" class="headerlink" title="The Tower of Babylon"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/UVA437">The Tower of Babylon</a></h3><h4 id="Descrpition"><a href="#Descrpition" class="headerlink" title="Descrpition"></a>Descrpition</h4><p>Perhaps you have heard of the legend of the Tower of Babylon. Nowadays many details of this tale have been forgotten. So now, in line with the educational nature of this contest, we will tell you the whole story:</p>
<p>The babylonians had n types of blocks, and an unlimited supply of blocks of each type. Each type-i block was a rectangular solid with linear dimensions (xi,yi,zi). A block could be reoriented so that any two of its three dimensions determined the dimensions of the base and the other dimension was the height.</p>
<p>They wanted to construct the tallest tower possible by stacking blocks. The problem was that, in building a tower, one block could only be placed on top of another block as long as the two base dimensions of the upper block were both strictly smaller than the corresponding base dimensions of the lower block. This meant, for example, that blocks oriented to have equal-sized bases couldn’t be stacked.</p>
<p>Your job is to write a program that determines the height of the tallest tower the babylonians can build with a given set of blocks.</p>
<h4 id="Input-5"><a href="#Input-5" class="headerlink" title="Input"></a>Input</h4><p>The input file will contain one or more test cases. The first line of each test case contains an integer n, representing the number of different blocks in the following data set. The maximum value for n is 30.</p>
<p>Each of the next n lines contains three integers representing the values xi, yi and zi. Input is terminated by a value of zero (0) for n.</p>
<h4 id="Output-5"><a href="#Output-5" class="headerlink" title="Output"></a>Output</h4><p>For each test case, print one line containing the case number (they are numbered sequentially starting from 1) and the height of the tallest possible tower in the format</p>
<p>‘Case case: maximum height &#x3D; height’</p>
<h4 id="Sample-Input-3"><a href="#Sample-Input-3" class="headerlink" title="Sample Input"></a>Sample Input</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">10 20 30</span><br><span class="line">2</span><br><span class="line">6 8 10</span><br><span class="line">5 5 5</span><br><span class="line">7</span><br><span class="line">1 1 1</span><br><span class="line">2 2 2</span><br><span class="line">3 3 3</span><br><span class="line">4 4 4</span><br><span class="line">5 5 5</span><br><span class="line">6 6 6</span><br><span class="line">7 7 7</span><br><span class="line">5</span><br><span class="line">31 41 59</span><br><span class="line">26 53 58</span><br><span class="line">97 93 23</span><br><span class="line">84 62 64</span><br><span class="line">33 83 27</span><br><span class="line">0</span><br></pre></td></tr></table></figure>



<h4 id="Sample-Output-3"><a href="#Sample-Output-3" class="headerlink" title="Sample Output"></a>Sample Output</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Case 1: maximum height = 40</span><br><span class="line">Case 2: maximum height = 21</span><br><span class="line">Case 3: maximum height = 28</span><br><span class="line">Case 4: maximum height = 342</span><br></pre></td></tr></table></figure>



<h4 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h4><ul>
<li><p>建立 DAG</p>
<p>由于每个砖块的底面长宽分别严格小于它下方砖块的底面长宽，因此不难将这样一种关系作为建图的依据，而本题也就转化为最长路问题。</p>
<p>也就是说如果砖块 j 能放在砖块 i 上，那么 i 和 j 之间存在一条边 (i, j)，且边权就是砖块 j 所选取的高。</p>
<p>本题的另一个问题在于每个砖块的高有三种选法，怎样建图更合适呢？</p>
<p>不妨将每个砖块拆解为三种堆叠方式，即将一个砖块分解为三个砖块，每一个拆解得到的砖块都选取不同的高。</p>
<p>初始的起点是大地，大地的底面是无穷大的，则大地可达任意砖块，当然我们写程序时不必特意写上无穷大。</p>
<p>假设有两个砖块，三条边分别为 31, 41, 59 和 33, 83, 27，那么整张 DAG 应该如下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/OwlllOvO/Hexo-image/20210509235622.png" alt="DAG"></p>
<p>图中蓝实框所表示的是一个砖块拆解得到的一组砖块，之所以用 {} 表示底面边长，是因为砖块一旦选取了高，底面边长就是无序的。</p>
<p>图中黄虚框表示的是重复计算部分，为下文做铺垫。</p>
</li>
<li><p>转移</p>
<p>题目要求的是塔的最大高度，已经转化为最长路问题，其起点上文已指出是大地，那么终点呢？</p>
<p>显然终点已经自然确定，那就是某砖块上不能再搭别的砖块的时候。</p>
<p>之前在图上标记的黄虚框表明有重复计算，下面我们开始考虑转移方程。</p>
<p>显然，砖块一旦选取了高，那么这块砖块上最大能放的高度是确定的。</p>
<p>某个砖块 i 有三种堆叠方式分别记为 0, 1, 2，那么对于砖块 i 和其堆叠方式 r 来说则有如下转移方程 <code>d(i, r) = max(d(j, r&#39;) + h&#39;)</code></p>
<p>其中 j 是所有那些在砖块 i 以 r 方式堆叠时可放上的砖块，r’ 对应 j 此时的摆放方式，也就确定了此时唯一的高度 h’。</p>
<p>在实际编写时，将所有 d(i, r) 都初始化为 -1，表示未计算过。</p>
<p>在试图计算前，如果发现已经计算过，直接返回保存的值；否则就按步计算，并保存。</p>
<p>最终答案是所有 d(i, r) 的最大值。</p>
</li>
</ul>
<h4 id="Accepted-Code-4"><a href="#Accepted-Code-4" class="headerlink" title="Accepted Code"></a>Accepted Code</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRTSECURE_NOWARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:4996)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 35</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXV 505</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line"><span class="type">int</span> d[MAXN][<span class="number">3</span>];</span><br><span class="line"><span class="type">int</span> x[MAXN], y[MAXN], z[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">babylon_sub</span><span class="params">(<span class="type">int</span> c, <span class="type">int</span> rot, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (d[c][rot] != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> d[c][rot];</span><br><span class="line">    &#125;</span><br><span class="line">    d[c][rot] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> base1 = <span class="number">0</span>, base2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (rot == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        base1 = x[c];</span><br><span class="line">        base2 = y[c];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rot == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        base1 = y[c];</span><br><span class="line">        base2 = z[c];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rot == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        base1 = x[c];</span><br><span class="line">        base2 = z[c];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((x[i] &lt; base1 &amp;&amp; y[i] &lt; base2) || (y[i] &lt; base1 &amp;&amp; x[i] &lt; base2))</span><br><span class="line">            d[c][rot] = <span class="built_in">max</span>(d[c][rot], <span class="built_in">babylon_sub</span>(i, <span class="number">0</span>, n) + z[i]);</span><br><span class="line">        <span class="keyword">if</span> ((y[i] &lt; base1 &amp;&amp; z[i] &lt; base2) || (z[i] &lt; base1 &amp;&amp; y[i] &lt; base2))</span><br><span class="line">            d[c][rot] = <span class="built_in">max</span>(d[c][rot], <span class="built_in">babylon_sub</span>(i, <span class="number">1</span>, n) + x[i]);</span><br><span class="line">        <span class="keyword">if</span> ((x[i] &lt; base1 &amp;&amp; z[i] &lt; base2) || (z[i] &lt; base1 &amp;&amp; x[i] &lt; base2))</span><br><span class="line">            d[c][rot] = <span class="built_in">max</span>(d[c][rot], <span class="built_in">babylon_sub</span>(i, <span class="number">2</span>, n) + y[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> d[c][rot];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">babylon</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        d[i][<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">        d[i][<span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">        d[i][<span class="number">2</span>] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        r = <span class="built_in">max</span>(r, <span class="built_in">babylon_sub</span>(i, <span class="number">0</span>, n) + z[i]);</span><br><span class="line">        r = <span class="built_in">max</span>(r, <span class="built_in">babylon_sub</span>(i, <span class="number">1</span>, n) + x[i]);</span><br><span class="line">        r = <span class="built_in">max</span>(r, <span class="built_in">babylon_sub</span>(i, <span class="number">2</span>, n) + y[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span> (<span class="string">&quot;%d%d%d&quot;</span>, &amp;x[i], &amp;y[i], &amp;z[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;Case %d: maximum height = %d\n&quot;</span>, ++t, <span class="built_in">babylon</span>(n));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="树形-DP"><a href="#树形-DP" class="headerlink" title="树形 DP"></a>树形 DP</h2><h3 id="简介-9"><a href="#简介-9" class="headerlink" title="简介"></a>简介</h3><p>树形 DP，即在树上进行的 DP。由于树固有的递归性质，树形 DP 一般都是递归进行的。</p>
<h3 id="特点-8"><a href="#特点-8" class="headerlink" title="特点"></a>特点</h3><ul>
<li>不存在环</li>
<li>具有明显而又严格的层数关系</li>
</ul>
<h3 id="建树"><a href="#建树" class="headerlink" title="建树"></a>建树</h3><p>如果节点数小于 5000，那么我们可以用邻接矩阵存储，如果更大可以用邻接表来存储（注意边要开到 2 * n，因为是双向的）。如果是二叉树或者是需要多叉转二叉，那么我们可以用两个一维数组 brother[], child[] 来存储</p>
<h3 id="树形-DP-方程"><a href="#树形-DP-方程" class="headerlink" title="树形 DP 方程"></a>树形 DP 方程</h3><p>通过观察孩子和父亲之间的关系建立方程。我们通常认为，树形DP的写法有两种：</p>
<ol>
<li>根到叶子，不过这种动态规划在实际的问题中运用的不多。</li>
<li>叶子到根：即根的子节点传递有用的信息给根，完后根得出最优解的过程。这类的习题比较的多。</li>
</ol>
<p>注：这两种写法一般情况下是不能相互转化的。但是有时可以同时使用</p>
<h3 id="加分二叉树"><a href="#加分二叉树" class="headerlink" title="加分二叉树"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1040">加分二叉树</a></h3><h4 id="Description-5"><a href="#Description-5" class="headerlink" title="Description"></a>Description</h4><p>设一个 n<em>n</em> 个节点的二叉树 tree 的中序遍历为 (1, 2, 3, …, n)，其中数字 1, 2, 3, …, n 为节点编号。每个节点都有一个分数（均为正整数），记第 i 个节点的分数为 d<sub>i</sub>，tree 及它的每个子树都有一个加分，任一棵子树 subtree（也包含 tree 本身）的加分计算方法如下：</p>
<p>subtree 的左子树的加分 × subtree 的右子树的加分 + subtree 的根的分数。</p>
<p>若某个子树为空，规定其加分为 1，叶子的加分就是叶节点本身的分数。不考虑它的空子树。</p>
<p>试求一棵符合中序遍历为 (1, 2, 3, …, n) 且加分最高的二叉树 tree。要求输出tree 的最高加分。tree 的前序遍历。</p>
<h4 id="Input-6"><a href="#Input-6" class="headerlink" title="Input"></a>Input</h4><p>第 1 行 1 个整数 n，为节点个数。</p>
<p>第 2 行 n 个用空格隔开的整数，为每个节点的分数</p>
<h4 id="Output-6"><a href="#Output-6" class="headerlink" title="Output"></a>Output</h4><p>第 1 行 1 个整数，为最高加分（ans ≤ 4,000,000,000）。</p>
<p>第 2 行 n 个用空格隔开的整数，为该树的前序遍历。</p>
<h4 id="Sample-Input-4"><a href="#Sample-Input-4" class="headerlink" title="Sample Input"></a>Sample Input</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">5 7 1 2 10</span><br></pre></td></tr></table></figure>



<h4 id="Sample-Output-4"><a href="#Sample-Output-4" class="headerlink" title="Sample Output"></a>Sample Output</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">145</span><br><span class="line">3 1 2 4 5</span><br></pre></td></tr></table></figure>



<h4 id="Hint-2"><a href="#Hint-2" class="headerlink" title="Hint"></a>Hint</h4><p>n &lt; 30</p>
<p>分数 &lt; 100</p>
<h4 id="Solution-6"><a href="#Solution-6" class="headerlink" title="Solution"></a>Solution</h4><p>看到这个问题，我们首先应该想到的是这道题是否属于动态规划，而这里我们发现，结合问题，如果整棵树的权值最大，必然有左子树的权值最大，右子树的权值也最大，符合最优性原理。所以是动态规划。</p>
<p>而却不是一道树规的题目。因为我们可以用区间动规的模型解决掉：直接定义一个 f[i][j] 表示从 i 到 j 的最大值，则 <code>f[i][j] = max(f[i][k-1] * f[k+1][j] + f[k][k])</code>，枚举 k 即可。接下来是如何建树的问题，只有把树建好了，才能输出其前序遍历。于是，我们看到了两个关键词：二叉树，中序遍历。有了这两个关键词，加上区间动规，这棵树就能建起来了。根据二叉树的特性来建树。所以这颗树的前序遍历，只需要边动规边记录下 root[i][j] &#x3D; k 表示 i 到 j 的根为 k 即可确定树的构造。</p>
<h4 id="Accepted-Code-5"><a href="#Accepted-Code-5" class="headerlink" title="Accepted Code"></a>Accepted Code</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRTSECURE_NOWARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:4996)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> n;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> f[MAXN][MAXN], root[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">long</span> <span class="type">long</span> l, <span class="type">long</span> <span class="type">long</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r)<span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>, root[l][r]);</span><br><span class="line">    <span class="keyword">if</span> (l == r)<span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">print</span>(l, root[l][r] - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">print</span>(root[l][r]<span class="number">+1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;f[i][i]);</span><br><span class="line">        f[i][i<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">        root[i][i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">1</span>; len &lt; n; ++len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i + len &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = i + len;</span><br><span class="line">            f[i][j] = f[i + <span class="number">1</span>][j] + f[i][i];    <span class="comment">//默认它的左子树为空，如果有的话，这肯定不是最优解</span></span><br><span class="line">            root[i][j] = i; <span class="comment">//默认从起点选根</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = i + <span class="number">1</span>; k &lt; j; ++k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (f[i][j] &lt; f[i][k - <span class="number">1</span>] * f[k + <span class="number">1</span>][j] + f[k][k])</span><br><span class="line">                &#123;</span><br><span class="line">                    f[i][j] = f[i][k - <span class="number">1</span>] * f[k + <span class="number">1</span>][j] + f[k][k];</span><br><span class="line">                    root[i][j] = k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; f[<span class="number">1</span>][n] &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>, n);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="树上背包-·-选课"><a href="#树上背包-·-选课" class="headerlink" title="树上背包 · 选课"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2014">树上背包 · 选课</a></h3><h4 id="Description-6"><a href="#Description-6" class="headerlink" title="Description"></a>Description</h4><p>在大学里每个学生，为了达到一定的学分，必须从很多课程里选择一些课程来学习，在课程里有些课程必须在某些课程之前学习，如高等数学总是在其它课程之前学习。现在有 N 门功课，每门课有个学分，每门课有一门或没有直接先修课（若课程 a 是课程 b 的先修课即只有学完了课程 a，才能学习课程 b）。一个学生要从这些课程里选择 M 门课程学习，问他能获得的最大学分是多少？</p>
<h4 id="Input-7"><a href="#Input-7" class="headerlink" title="Input"></a>Input</h4><p>第一行有两个整数 N , M 用空格隔开。(1 ≤ N ≤ 300, 1 ≤ M ≤ 300) 接下来的 N 行,第 I + 1 行包含两个整数 k<sub>i</sub> 和 s<sub>i</sub>, k<sub>i</sub> 表示第I门课的直接先修课，s<sub>i</sub> 表示第 I 门课的学分。若 k<sub>i</sub> &#x3D; 0 表示没有直接先修课（1 ≤ k<sub>i</sub> ≤ N, 1 ≤ s<sub>i</sub> ≤ 20）。</p>
<h4 id="Output-7"><a href="#Output-7" class="headerlink" title="Output"></a>Output</h4><p>只有一行，选 M 门课程的最大得分。</p>
<h4 id="Sample-Input-5"><a href="#Sample-Input-5" class="headerlink" title="Sample Input"></a>Sample Input</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">7  4</span><br><span class="line">2  2</span><br><span class="line">0  1</span><br><span class="line">0  4</span><br><span class="line">2  1</span><br><span class="line">7  1</span><br><span class="line">7  6</span><br><span class="line">2  2</span><br></pre></td></tr></table></figure>



<h4 id="Sample-Output-5"><a href="#Sample-Output-5" class="headerlink" title="Sample Output"></a>Sample Output</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">13</span><br></pre></td></tr></table></figure>



<h4 id="Solution-7"><a href="#Solution-7" class="headerlink" title="Solution"></a>Solution</h4><p>这道题的意思是每本书要想选择一门课，必须要先学会它的必修课，所以这就形成了一种依赖行为，即选择一门课必须要选择必修课。那么他又说要选择的价值最大，这就要用到树形背包的知识了。</p>
<p>树形背包的基本代码形式（即上面的树形背包类）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">设dp[i][j]表示选择以i为根的子树中j个节点。</span></span><br><span class="line"><span class="comment">u代表当前根节点，tot代表其选择的节点的总额。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> tot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = head[x]; i; i = e[i].next)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> v = e[i].to;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; tot; k++)	<span class="comment">//这里k从o开始到tot-1，因为v的子树可以选择的节点是u的子树的节点数减一</span></span><br><span class="line">			dp[v][k] = dp[u][k] + val[u];</span><br><span class="line">		<span class="built_in">dfs</span>(v, tot - <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= tot; k++)</span><br><span class="line">			dp[u][k] = <span class="built_in">max</span>(dp[u][k], dp[v][k<span class="number">-1</span>]);	<span class="comment">//这里是把子树的值赋给了根节点，因为u选择k个点v只能选择k-1个点。</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Accepted-Code-6"><a href="#Accepted-Code-6" class="headerlink" title="Accepted Code"></a>Accepted Code</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRTSECURE_NOWARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:4996)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> next,to;</span><br><span class="line">&#125;e[<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> rt, head[<span class="number">1000</span>], tot, val[<span class="number">1000</span>], dp[<span class="number">1000</span>][<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++tot].next=head[x];</span><br><span class="line">    head[x] = tot;</span><br><span class="line">    e[tot].to = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v = e[i].to;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; t; ++k)</span><br><span class="line">            dp[v][k] = dp[u][k] + val[v];</span><br><span class="line">        <span class="built_in">dfs</span>(v, t - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= t; ++k)</span><br><span class="line">            dp[u][k] = <span class="built_in">max</span>(dp[u][k], dp[v][k<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;val[i]);</span><br><span class="line">        <span class="keyword">if</span>(a)  <span class="built_in">add</span>(a, i);</span><br><span class="line">        <span class="keyword">if</span>(!a) <span class="built_in">add</span>(<span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, m);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, dp[<span class="number">0</span>][m]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="状压-DP"><a href="#状压-DP" class="headerlink" title="状压 DP"></a>状压 DP</h2><h3 id="简介-10"><a href="#简介-10" class="headerlink" title="简介"></a>简介</h3><p>状压 dp 是动态规划的一种，通过将状态压缩为整数来达到优化转移的目的。</p>
<h3 id="互不侵犯"><a href="#互不侵犯" class="headerlink" title="互不侵犯"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1896">互不侵犯</a></h3><h4 id="Descrpition-1"><a href="#Descrpition-1" class="headerlink" title="Descrpition"></a>Descrpition</h4><p>在 N × N 的棋盘里面放 K 个国王，使他们互不攻击，共有多少种摆放方案。国王能攻击到它上下左右，以及左上左下右上右下八个方向上附近的各一个格子，共 8 个格子。</p>
<h4 id="Input-8"><a href="#Input-8" class="headerlink" title="Input"></a>Input</h4><p>只有一行，包含两个数 N，K (1 &lt;&#x3D; N &lt;&#x3D;9, 0 &lt;&#x3D; K &lt;&#x3D; N * N)</p>
<h4 id="Output-8"><a href="#Output-8" class="headerlink" title="Output"></a>Output</h4><p>所得的方案数</p>
<h4 id="Sample-Input-6"><a href="#Sample-Input-6" class="headerlink" title="Sample Input"></a>Sample Input</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 2</span><br></pre></td></tr></table></figure>



<h4 id="Sample-Output-6"><a href="#Sample-Output-6" class="headerlink" title="Sample Output"></a>Sample Output</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">16</span><br></pre></td></tr></table></figure>



<h4 id="Solution-8"><a href="#Solution-8" class="headerlink" title="Solution"></a>Solution</h4><p>首先，看到这一题，就知道如果不是搜索，就是 DP。当然搜索是过不了的，所以就应该尝试想出一个 DP 的解法。</p>
<p>DP 的前提之一当然是要找出一个可以互相递推的状态。显然，目前已使用的国王个数当然必须是状态中的一个部分，因为这是一个限制条件。那么除此之外另外的部分是什么呢？</p>
<p>我们考虑到每行每列之间都有互相的约束关系。因此，我们可以用行和列作为另一个状态的部分（矩阵状压 DP 常用行作为状态，一下的论述中也用行作为状态）。</p>
<p>又看到数据范围： 1 &lt;&#x3D; N &lt;&#x3D; 9。这里我们就可以用一个新的方法表示行和列的状态：数字。考虑任何一个十进制数都可以转化成一个二进制数，而一行的状态就可以表示成这样——例如：</p>
<p>1010 (2 进制)</p>
<p>就表示：这一行的第一个格子没有国王，第二个格子放了国王，第三个格子没有放国王，第四个格子放了国王（注意，格子从左到右的顺序是与二进制从左到右的顺序相反的，因为真正在程序进行处理的时候就像是这样的）。而这个二进制下的数就可以转化成十进制：</p>
<p>10 (10)</p>
<p>于是，我们的三个状态就有了：第几行（用 i 表示）、此行放什么状态（用 j 表示）、包括这一行已经使用了的国王数（用 s 表示）。</p>
<p>考虑状态转移方程。我们预先处理出每一个状态（sit[x]）其中包含二进制下 1 的个数，及此状态下这一行放的国王个数（gs[x]），于是就有：</p>
<p><code>f[i][j][s] = sum(f[i−1][k][s−gs[j]])</code>，f[i][j][s] 就表示在只考虑前 i 行时，在前 i 行（包括第 i 行）有且仅有 s 个国王，且第 i 行国王的情况是编号为 j 的状态时情况的总数。而 k 就代表第 i - 1 行的国王情况的状态编号</p>
<p>其中 k 在 1 到 n 之间，j 与 k 都表示状态的编号，且 k 与 j 必须满足两行之间国王要满足的关系。（对于这一点的处理我们待会儿再说）</p>
<p>这个状态转移方程也十分好理解。其实就是上一行所有能够与这一行要使用的状态切合的状态都计入状态统计的加和当中。其中 i, j, s, k 都要枚举。</p>
<p>再考虑国王之间的关系该如何处理呢？在同一行国王之间的关系我们可以直接在预处理状态时舍去那些不符合题意的状态，而相邻行之间的关系我们就可以用到一个高端的东西：位运算。由于状态已经用数字表示了，因此我们可以用与（∧）运算来判断两个状态在同一个或者相邻位置是否都有国王——如果：</p>
<p>sit[j] &amp; sit[k] (及上下有重复的king)</p>
<p>(sit[j] &lt;&lt; 1) &amp; sit[k] (及左上右下有重复king)</p>
<p>sit[j] &amp; (sit[k]&lt;&lt;1) (及右上左下有重复king)</p>
<p>这样就可以处理掉那些不符合题意的状态了。</p>
<p>总结一下。其实状压 DP 不过就是将一个状态转化成一个数，然后用位运算进行状态的处理。理解了这一点，其实就跟普通的 DP 没有什么两样了。</p>
<h4 id="Accepted-Code-7"><a href="#Accepted-Code-7" class="headerlink" title="Accepted Code"></a>Accepted Code</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRTSECURE_NOWARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:4996)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sit[<span class="number">2000</span>], gs[<span class="number">2000</span>];</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> n, yong;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> f[<span class="number">10</span>][<span class="number">2000</span>][<span class="number">100</span>], ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> he, <span class="type">int</span> sum, <span class="type">int</span> node)</span> <span class="comment">//预处理出每一个状态</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node &gt;= n)   <span class="comment">//如果已经处理完毕（注意是大于等于）</span></span><br><span class="line">    &#123;</span><br><span class="line">        sit[++cnt] = he;</span><br><span class="line">        gs[cnt] = sum;</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">//新建一个状态</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(he, sum, node + <span class="number">1</span>); <span class="comment">//不用第node个</span></span><br><span class="line">    <span class="built_in">dfs</span>(he + (<span class="number">1</span> &lt;&lt; node), sum + <span class="number">1</span>, node + <span class="number">2</span>);   <span class="comment">//用第node个，此时node要加2，及跳过下一个格子</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;yong);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) f[<span class="number">1</span>][i][gs[i]] = <span class="number">1</span>;   <span class="comment">//第一层的所有状态均是有1种情况的</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= cnt; j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= cnt; k++)   <span class="comment">//枚举i、j、k</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(sit[j] &amp; sit[k]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>((sit[j] &lt;&lt; <span class="number">1</span>) &amp; sit[k]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(sit[j] &amp; (sit[k] &lt;&lt; <span class="number">1</span>)) <span class="keyword">continue</span>;    <span class="comment">//排除不合法国王情况</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> s = yong; s &gt;= gs[j]; s--)  <span class="comment">//枚举s，计算f[i][j][s]</span></span><br><span class="line">                    f[i][j][s] += f[i<span class="number">-1</span>][k][s-gs[j]];</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++)</span><br><span class="line">        ans += f[n][i][yong];   <span class="comment">//统计最终答案，记得用long long</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, ans);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="数位-DP"><a href="#数位-DP" class="headerlink" title="数位 DP"></a>数位 DP</h2><h3 id="简介-11"><a href="#简介-11" class="headerlink" title="简介"></a>简介</h3><p>数位 DP 问题往往都是这样的题型，给定一个闭区间 [l, r]，让你求这个区间中满足 <strong>某种条件</strong> 的数的总数。 </p>
<h3 id="数字计数"><a href="#数字计数" class="headerlink" title="数字计数"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2602">数字计数</a></h3><h4 id="Description-7"><a href="#Description-7" class="headerlink" title="Description"></a>Description</h4><p>给定两个正整数 a 和 b，求在 [a,b] 中的所有整数中，每个数码(digit)各出现了多少次。</p>
<h4 id="Input-9"><a href="#Input-9" class="headerlink" title="Input"></a>Input</h4><p>仅包含一行两个整数 a, b，含义如上所述。</p>
<h4 id="Output-9"><a href="#Output-9" class="headerlink" title="Output"></a>Output</h4><p>包含一行十个整数，分别表示 0∼9 在 [a,b] 中出现了多少次。</p>
<h4 id="Sample-Input-7"><a href="#Sample-Input-7" class="headerlink" title="Sample Input"></a>Sample Input</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 99</span><br></pre></td></tr></table></figure>



<h4 id="Sample-Output-7"><a href="#Sample-Output-7" class="headerlink" title="Sample Output"></a>Sample Output</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9 20 20 20 20 20 20 20 20 20</span><br></pre></td></tr></table></figure>



<h4 id="Hint-3"><a href="#Hint-3" class="headerlink" title="Hint"></a>Hint</h4><ul>
<li>对于 30% 的数据，保证 a ≤ b ≤ 10<sup>6</sup>；</li>
<li>对于 100% 的数据，保证 1 ≤ a ≤ b ≤ 10<sup>12</sup>。</li>
</ul>
<h4 id="Solution-9"><a href="#Solution-9" class="headerlink" title="Solution"></a>Solution</h4><p>f[i] 代表在有i位数字的情况下，每个数字有多少个。如果不考虑前导 0，你会发现对于每一个数，它的数量都是相等的，也就是 f[i] &#x3D; f[i-1] * 10 + 10<sup>i - 1</sup>;</p>
<p>我们先设数字为 ABCD</p>
<p>看 A000，如果我们要求出它所有数位之和，我们会怎么求？</p>
<p>鉴于我们其实已经求出了 0 ~ 9, 0 ~ 99, 0 ~ 999… 上所有数字个数（f[i], 且没有考虑前导 0）我们何不把这个 A000 看成 0000 ~ 1000 ~ 2000… A000 对于不考虑首位每一个式子的数字的出现个数为 A * f[3]。加上首位出现也就是小于 A 每一个数都出现了 10<sup>3</sup> 次，再加上，我们就把 A000 处理完了。</p>
<p>这样你以为就把第一位处理完了？不不不，首位 A 还出现了 BCD + 1 次呢，也就是从 A000 ~ ABCD，这个 A 还出现了 BCD + 1 次，所以再加上这些才行呢。那么你发现，我们成功把首位代表的所有数字个数求出来了，剩下的求解与 A 完全没有任何关系，只是 BCD 的求解，于是我们发现我们已经把一个大问题，化成了一个个小问题，也即是，对于一个这样 n 位的数，把他一位位的分离开来。</p>
<p>当然你还需要处理前导 0 你会发现前导 0 一定是 0001, 0002, …, 0012, 0013, …, 0101, 0102, …, 0999 这样的数，一共出现了 10 *(i - 1) + 10 * (i - 2) + … 10 (i 表示数字位数），让 0 的统计减去这个值，那么恭喜你这道题做完了。</p>
<p>总结 对于 DP 这个东西，最重要的其实只有一点，推状态，状态又是什么？是大问题的子问题，对于这种题最重要的特点是，无后效性，问题可拆分，并且答案的求解具有一定的规律，这样的题应该就可以用 DP 做，数位 DP 最重要的就是把一整个数字拆分成一位一位的单独来看，那么对于数位 DP，它的子问题也就一般是每一位上对于答案的求解，层层递进的这么一个思路。</p>
<h4 id="Accepted-Code-8"><a href="#Accepted-Code-8" class="headerlink" title="Accepted Code"></a>Accepted Code</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRTSECURE_NOWARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:4996)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> a,b;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ten[<span class="number">20</span>],f[<span class="number">20</span>];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> cnta[<span class="number">20</span>],cntb[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">long</span> <span class="type">long</span> x,<span class="type">long</span> <span class="type">long</span> *cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> num[<span class="number">20</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        num[++len]=x%<span class="number">10</span>;</span><br><span class="line">        x=x/<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=len;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">9</span>;j++)</span><br><span class="line">        cnt[j]+=f[i<span class="number">-1</span>]*num[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;num[i];j++)</span><br><span class="line">        cnt[j]+=ten[i<span class="number">-1</span>];</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> num2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">-1</span>;j&gt;=<span class="number">1</span>;j--)</span><br><span class="line">        &#123;</span><br><span class="line">            num2=num2*<span class="number">10</span>+num[j];</span><br><span class="line">        &#125;</span><br><span class="line">        cnt[num[i]]+=num2<span class="number">+1</span>;</span><br><span class="line">        cnt[<span class="number">0</span>]-=ten[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">    ten[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">15</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i]=f[i<span class="number">-1</span>]*<span class="number">10</span>+ten[i<span class="number">-1</span>];</span><br><span class="line">        ten[i]=<span class="number">10</span>*ten[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">solve</span>(a<span class="number">-1</span>,cnta);</span><br><span class="line">    <span class="built_in">solve</span>(b,cntb);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">9</span>;i++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,cntb[i]-cnta[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




































      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/02/2021-5-2-dp/" data-id="clz6fe7hv001w0loxgcwnhf90" data-title="DP" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DP/" rel="tag">DP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8C%BA%E9%97%B4DP/" rel="tag">区间DP</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-2021-4-27-Vim" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/27/2021-4-27-vim/" class="article-date">
  <time class="dt-published" datetime="2021-04-27T13:00:00.000Z" itemprop="datePublished">2021-04-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Coding/">Coding</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/27/2021-4-27-vim/">Vim</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h1><h2 id="What-is-Vim"><a href="#What-is-Vim" class="headerlink" title="What is Vim?"></a>What is Vim?</h2><blockquote>
<p>Vim is a greatly improved version of the good old UNIX editor Vi. Many new features have been added: multi-level undo, syntax highlighting, command line history, on-line help, spell checking, filename completion, block operations, script language, etc. There is also a Graphical User Interface (GUI) available. Still, Vi compatibility is maintained, those who have Vi “in the fingers” will feel at home. See runtime&#x2F;doc&#x2F;vi_diff.txt for differences with Vi.</p>
<p>This editor is very useful for editing programs and other plain text files. All commands are given with normal keyboard characters, so those who can type with ten fingers can work very fast. Additionally, function keys can be mapped to commands by the user, and the mouse can be used.</p>
<p>Vim runs under MS-Windows (XP, Vista, 7, 8, 10), macOS, Haiku, VMS and almost all flavours of UNIX. Porting to other systems should not be very difficult. Older versions of Vim run on MS-DOS, MS-Windows 95&#x2F;98&#x2F;Me&#x2F;NT&#x2F;2000, Amiga DOS, Atari MiNT, BeOS, RISC OS and OS&#x2F;2. These are no longer maintained.</p>
<p>——Github&#x2F;Vim</p>
</blockquote>
<h2 id="How-to-use-Vim"><a href="#How-to-use-Vim" class="headerlink" title="How to use Vim?"></a>How to use Vim?</h2><p>In Terminal</p>
<ul>
<li><p><code>vim</code> : Open Vim</p>
</li>
<li><p><code>vim [filename]</code> : Open [filename] in Vim</p>
</li>
</ul>
<h2 id="Modes"><a href="#Modes" class="headerlink" title="Modes"></a>Modes</h2><p>In Vim, there are three modes of operation: Normal, Insert, and Visual.</p>
<h3 id="Normal-mode"><a href="#Normal-mode" class="headerlink" title="Normal mode"></a>Normal mode</h3><p>Normal mode is the initial mode of the Vim editor. When you open a new file edit an existing one, it starts in normal mode by default. In normal mode, you cannot insert any character. Normal mode is also known as command mode because all the keystrokes you perform are interpreted as commands.</p>
<p><strong>To access normal mode from other modes, press <code>Esc</code> key.</strong></p>
<h3 id="Insert-mode"><a href="#Insert-mode" class="headerlink" title="Insert mode"></a>Insert mode</h3><p>Insert mode is where you can insert your text in the file. This mode inserts every character you type at the current cursor location.</p>
<h3 id="Visual-mode"><a href="#Visual-mode" class="headerlink" title="Visual mode"></a>Visual mode</h3><p>Visual mode allows you to select text so that you may perform certain operations (cut, copy, delete) on it.</p>
<h3 id="Changing-the-modes"><a href="#Changing-the-modes" class="headerlink" title="Changing the modes"></a>Changing the modes</h3><ul>
<li>When creating or opening a file in vim, it first opens in Normal mode.</li>
<li>Switch to Insert mode from Normal mode: <code>i</code> or <code>I</code>, <code>o</code>, <code>O</code>, <code>a</code>, <code>A</code>.</li>
<li>Switch to Visual mode from Normal mode: <code>v</code> or <code>V</code></li>
<li>Switch between Inset mode and Visual mode: shift to Normal mode first.</li>
</ul>
<h2 id="Commands-in-Normal-mode"><a href="#Commands-in-Normal-mode" class="headerlink" title="Commands (in Normal mode)"></a>Commands (in Normal mode)</h2><h3 id="File-related-commands"><a href="#File-related-commands" class="headerlink" title="File related commands"></a>File related commands</h3><table>
<thead>
<tr>
<th align="left">Key</th>
<th align="left">Command</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>:w</code></td>
<td align="left">Write the file to the disk</td>
</tr>
<tr>
<td align="left"><code>:w [filename]</code></td>
<td align="left">Save the file as <em>[filename]</em></td>
</tr>
<tr>
<td align="left"><code>:q</code></td>
<td align="left">Quit vi without saving the file</td>
</tr>
<tr>
<td align="left"><code>:wq</code></td>
<td align="left">Write the file to disk and quit vim</td>
</tr>
<tr>
<td align="left"><code>:wq [filename]</code></td>
<td align="left">Quit and save the file as [filename]</td>
</tr>
<tr>
<td align="left"><code>:q!</code></td>
<td align="left">Ignore the warning and discard the change</td>
</tr>
</tbody></table>
<h3 id="Moving-the-cursor"><a href="#Moving-the-cursor" class="headerlink" title="Moving the cursor"></a>Moving the cursor</h3><table>
<thead>
<tr>
<th>Key</th>
<th>Command</th>
</tr>
</thead>
<tbody><tr>
<td><code>h</code> &#x2F; <code>Left</code></td>
<td>Move the cursor <strong>left</strong> one <strong>character</strong></td>
</tr>
<tr>
<td><code>j</code> &#x2F; <code>Down</code></td>
<td>Move the cursor <strong>down</strong> one <strong>line</strong></td>
</tr>
<tr>
<td><code>k</code> &#x2F; <code>Up</code></td>
<td>Move the cursor <strong>up</strong> one <strong>line</strong></td>
</tr>
<tr>
<td><code>l</code> &#x2F; <code>Right</code></td>
<td>Move the cursor <strong>right</strong> one <strong>character</strong></td>
</tr>
<tr>
<td><code>w</code></td>
<td>Move the cursor <strong>forward</strong> one <strong>word</strong></td>
</tr>
<tr>
<td><code>b</code></td>
<td>Move the cursor <strong>backward</strong> one <strong>word</strong></td>
</tr>
<tr>
<td><code>Control</code> <code>f</code> &#x2F; <code>Page Down</code></td>
<td>Move the cursor <strong>forward</strong> one <strong>page</strong></td>
</tr>
<tr>
<td><code>Control</code> <code>b</code> &#x2F; <code>Page Up</code></td>
<td>Move the cursor <strong>backward</strong> one <strong>page</strong></td>
</tr>
<tr>
<td><code>[number]gg</code></td>
<td>Move the cursor to line [number]</td>
</tr>
<tr>
<td><code>[number]j</code></td>
<td>Move the cursor <strong>down</strong> [number] lines</td>
</tr>
<tr>
<td><code>[number]k</code></td>
<td>Move the cursor <strong>up</strong> [number] lines</td>
</tr>
</tbody></table>
<h3 id="Finding-text"><a href="#Finding-text" class="headerlink" title="Finding text"></a>Finding text</h3><table>
<thead>
<tr>
<th>Key</th>
<th>Command</th>
</tr>
</thead>
<tbody><tr>
<td><code>/[text]</code></td>
<td>Find all [text]</td>
</tr>
<tr>
<td><code>n</code></td>
<td>Move to next [text]</td>
</tr>
<tr>
<td><code>Shift</code> <code>n</code></td>
<td>Move to previous [text]</td>
</tr>
</tbody></table>
<h3 id="Inserting-text"><a href="#Inserting-text" class="headerlink" title="Inserting text"></a>Inserting text</h3><table>
<thead>
<tr>
<th>Key</th>
<th>Command</th>
</tr>
</thead>
<tbody><tr>
<td><code>I</code></td>
<td>Insert text at the beginning of the line</td>
</tr>
<tr>
<td><code>i</code></td>
<td>Insert text before the current cursor location</td>
</tr>
<tr>
<td><code>a</code></td>
<td>Insert text after the current cursor location</td>
</tr>
<tr>
<td><code>o</code></td>
<td>Create a new line for the text below the current cursor location</td>
</tr>
<tr>
<td><code>O</code></td>
<td>Create a new line for text above the current cursor location</td>
</tr>
</tbody></table>
<h3 id="Changing-text"><a href="#Changing-text" class="headerlink" title="Changing text"></a>Changing text</h3><table>
<thead>
<tr>
<th>Key</th>
<th>Command</th>
</tr>
</thead>
<tbody><tr>
<td><code>cc</code></td>
<td>Remove the whole line and start Insert mode</td>
</tr>
<tr>
<td><code>c[number]c</code></td>
<td>Remove the whole [number] lines and start Insert mode</td>
</tr>
<tr>
<td><code>s</code></td>
<td>Remove the character under the cursor and start Insert mode</td>
</tr>
<tr>
<td><code>r</code></td>
<td>Replace the character under the cursor</td>
</tr>
</tbody></table>
<h3 id="Copying-Pasting"><a href="#Copying-Pasting" class="headerlink" title="Copying &amp; Pasting"></a>Copying &amp; Pasting</h3><table>
<thead>
<tr>
<th>Key</th>
<th>Command</th>
</tr>
</thead>
<tbody><tr>
<td><code>y</code></td>
<td>Copy the selected text to clipboard</td>
</tr>
<tr>
<td><code>yy</code></td>
<td>Copy current line</td>
</tr>
<tr>
<td><code>P</code></td>
<td>insert the text <strong>before</strong> the cursor</td>
</tr>
<tr>
<td><code>p</code></td>
<td>Insert the text at the point after the cursor</td>
</tr>
</tbody></table>
<h3 id="Deleting-text"><a href="#Deleting-text" class="headerlink" title="Deleting text"></a>Deleting text</h3><table>
<thead>
<tr>
<th>Key</th>
<th>Command</th>
</tr>
</thead>
<tbody><tr>
<td><code>X</code></td>
<td>Delete the character before the current location</td>
</tr>
<tr>
<td><code>x</code></td>
<td>Delete the character under the current location</td>
</tr>
<tr>
<td><code>D</code></td>
<td>Cut to the end of line</td>
</tr>
<tr>
<td><code>dd</code></td>
<td>Cut current line</td>
</tr>
</tbody></table>
<h3 id="Undo-Redo"><a href="#Undo-Redo" class="headerlink" title="Undo &amp; Redo"></a>Undo &amp; Redo</h3><table>
<thead>
<tr>
<th>Key</th>
<th>Command</th>
</tr>
</thead>
<tbody><tr>
<td><code>u</code></td>
<td>Undo last change</td>
</tr>
<tr>
<td><code>Control</code> <code>r</code></td>
<td>Redo last change</td>
</tr>
</tbody></table>
<h2 id="Customize-Vim"><a href="#Customize-Vim" class="headerlink" title="Customize Vim"></a>Customize Vim</h2><p>Enter <code>vim ~/.vimrc</code> in Terminal</p>
<ul>
<li><code>syntax on</code> : Code highlighting</li>
<li><code>set number</code> : Line number</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/27/2021-4-27-vim/" data-id="clz6fe7ht001f0loxfhi08hbo" data-title="Vim" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vim/" rel="tag">Vim</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/ACM/">ACM</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Coding/">Coding</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/HZNU/">HZNU</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Manual/">Manual</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tech/">Tech</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/01%E8%83%8C%E5%8C%85/" rel="tag">01背包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AC-%E8%87%AA%E5%8A%A8%E6%9C%BA/" rel="tag">AC 自动机</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Abstract-class/" rel="tag">Abstract class</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Account/" rel="tag">Account</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/App/" rel="tag">App</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BFS/" rel="tag">BFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DFS/" rel="tag">DFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DP/" rel="tag">DP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Dijkstra/" rel="tag">Dijkstra</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Eclipse/" rel="tag">Eclipse</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Email/" rel="tag">Email</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Floyd/" rel="tag">Floyd</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/" rel="tag">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/" rel="tag">Hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JAVA/" rel="tag">JAVA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/KMP/" rel="tag">KMP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kruskal/" rel="tag">Kruskal</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LCA/" rel="tag">LCA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mac/" rel="tag">Mac</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MathJax/" rel="tag">MathJax</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Media/" rel="tag">Media</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Prim/" rel="tag">Prim</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Regex/" rel="tag">Regex</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SPFA/" rel="tag">SPFA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/STL/" rel="tag">STL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Trie/" rel="tag">Trie</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/VPS/" rel="tag">VPS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vim/" rel="tag">Vim</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web/" rel="tag">Web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/aria2/" rel="tag">aria2</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/macOS/" rel="tag">macOS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/markdown/" rel="tag">markdown</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/qBittorrent/" rel="tag">qBittorrent</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%88%86/" rel="tag">二分</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/" rel="tag">二分图</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8C%BA%E9%97%B4DP/" rel="tag">区间DP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/" rel="tag">博弈论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9B%BE/" rel="tag">图</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/" rel="tag">多重背包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/" rel="tag">完全背包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/" rel="tag">并查集</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/" rel="tag">归并排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/" rel="tag">快速幂</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/" rel="tag">拓扑排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%90%9C%E7%B4%A2/" rel="tag">搜索</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E4%BD%8D-DP/" rel="tag">数位 DP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E8%AE%BA/" rel="tag">数论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/" rel="tag">最小生成树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A0%91/" rel="tag">树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/" rel="tag">线段树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/" rel="tag">计算几何</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%86%E5%BA%8F%E5%AF%B9/" rel="tag">逆序对</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/01%E8%83%8C%E5%8C%85/" style="font-size: 10px;">01背包</a> <a href="/tags/AC-%E8%87%AA%E5%8A%A8%E6%9C%BA/" style="font-size: 10px;">AC 自动机</a> <a href="/tags/Abstract-class/" style="font-size: 10px;">Abstract class</a> <a href="/tags/Account/" style="font-size: 10px;">Account</a> <a href="/tags/App/" style="font-size: 13.33px;">App</a> <a href="/tags/BFS/" style="font-size: 10px;">BFS</a> <a href="/tags/C/" style="font-size: 20px;">C++</a> <a href="/tags/DFS/" style="font-size: 10px;">DFS</a> <a href="/tags/DP/" style="font-size: 16.67px;">DP</a> <a href="/tags/Dijkstra/" style="font-size: 10px;">Dijkstra</a> <a href="/tags/Eclipse/" style="font-size: 10px;">Eclipse</a> <a href="/tags/Email/" style="font-size: 10px;">Email</a> <a href="/tags/Floyd/" style="font-size: 10px;">Floyd</a> <a href="/tags/Git/" style="font-size: 10px;">Git</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/JAVA/" style="font-size: 16.67px;">JAVA</a> <a href="/tags/KMP/" style="font-size: 10px;">KMP</a> <a href="/tags/Kruskal/" style="font-size: 10px;">Kruskal</a> <a href="/tags/LCA/" style="font-size: 10px;">LCA</a> <a href="/tags/Mac/" style="font-size: 10px;">Mac</a> <a href="/tags/MathJax/" style="font-size: 10px;">MathJax</a> <a href="/tags/Media/" style="font-size: 10px;">Media</a> <a href="/tags/Prim/" style="font-size: 10px;">Prim</a> <a href="/tags/Regex/" style="font-size: 10px;">Regex</a> <a href="/tags/SPFA/" style="font-size: 10px;">SPFA</a> <a href="/tags/STL/" style="font-size: 10px;">STL</a> <a href="/tags/Trie/" style="font-size: 10px;">Trie</a> <a href="/tags/VPS/" style="font-size: 10px;">VPS</a> <a href="/tags/Vim/" style="font-size: 10px;">Vim</a> <a href="/tags/Web/" style="font-size: 10px;">Web</a> <a href="/tags/aria2/" style="font-size: 10px;">aria2</a> <a href="/tags/macOS/" style="font-size: 10px;">macOS</a> <a href="/tags/markdown/" style="font-size: 10px;">markdown</a> <a href="/tags/qBittorrent/" style="font-size: 10px;">qBittorrent</a> <a href="/tags/%E4%BA%8C%E5%88%86/" style="font-size: 10px;">二分</a> <a href="/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/" style="font-size: 10px;">二分图</a> <a href="/tags/%E5%8C%BA%E9%97%B4DP/" style="font-size: 10px;">区间DP</a> <a href="/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/" style="font-size: 10px;">博弈论</a> <a href="/tags/%E5%9B%BE/" style="font-size: 10px;">图</a> <a href="/tags/%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/" style="font-size: 10px;">多重背包</a> <a href="/tags/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/" style="font-size: 10px;">完全背包</a> <a href="/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/" style="font-size: 10px;">并查集</a> <a href="/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/" style="font-size: 10px;">归并排序</a> <a href="/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/" style="font-size: 10px;">快速幂</a> <a href="/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/" style="font-size: 10px;">拓扑排序</a> <a href="/tags/%E6%90%9C%E7%B4%A2/" style="font-size: 10px;">搜索</a> <a href="/tags/%E6%95%B0%E4%BD%8D-DP/" style="font-size: 10px;">数位 DP</a> <a href="/tags/%E6%95%B0%E8%AE%BA/" style="font-size: 10px;">数论</a> <a href="/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/" style="font-size: 10px;">最小生成树</a> <a href="/tags/%E6%A0%91/" style="font-size: 10px;">树</a> <a href="/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/" style="font-size: 10px;">线段树</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/" style="font-size: 10px;">计算几何</a> <a href="/tags/%E9%80%86%E5%BA%8F%E5%AF%B9/" style="font-size: 10px;">逆序对</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">July 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">December 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">November 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">November 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/07/25/2024-07-25-mac-manual/">Mac Manual</a>
          </li>
        
          <li>
            <a href="/2024/07/12/2024-07-12-emby/">Emby</a>
          </li>
        
          <li>
            <a href="/2024/07/02/2024-07-02-vps-xia-zai-ji/">VPS 下载机</a>
          </li>
        
          <li>
            <a href="/2022/12/17/2022-12-17-simplelogin/">SimpleLogin</a>
          </li>
        
          <li>
            <a href="/2022/11/11/2022-11-11-my-blog/">My Blog</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 OwlllOvO<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>