<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Welcome to my blog">
<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Welcome to my blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="OwlllOvO">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">OwlllOvO&#39;s Blog</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-2021-4-12-KMP" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/12/2021-4-12-kmp/" class="article-date">
  <time class="dt-published" datetime="2021-04-12T13:12:44.000Z" itemprop="datePublished">2021-04-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/ACM/">ACM</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/12/2021-4-12-kmp/">KMP</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h1><h2 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h2><p>给定 2 个字符串 text 和 pattern，在 text 中寻找是否存在 pattern 这个子串（连续）</p>
<h3 id="传统方法-·-暴力"><a href="#传统方法-·-暴力" class="headerlink" title="传统方法 · 暴力"></a>传统方法 · 暴力</h3><h4 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h4><p>从第一位开始，对两个字符串进行逐位比对， 不相等则从下一位开始逐位比对</p>
<h4 id="复杂度-·-O-mn"><a href="#复杂度-·-O-mn" class="headerlink" title="复杂度 · O(mn)"></a>复杂度 · O(mn)</h4><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>KMP 算法是一种改进的字符串匹配算法，由 D.E.Knuth，J.H.Morris 和 V.R.Pratt 提出的，因此人们称它为克努特—莫里斯—普拉特操作（简称 KMP 算法）。KMP 算法的核心是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。具体实现就是通过一个 next() 函数实现，函数本身包含了模式串的局部匹配信息。</p>
<p>KMP 算法是三位学者在 Brute-Force 算法的基础上同时提出的模式匹配的改进算法。Brute- Force 算法在模式串中有多个字符和主串中的若干个连续字符比较都相等，但最后一个字符比较不相等时，主串的比较位置需要回退。KMP 算法在上述情况下，主串位置不需要回退，从而可以大大提高效率</p>
</blockquote>
<h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>不难发现，暴力的方法进行了大量的无效比对。如以下这个例子：text: “aaaaaaaaab”, pattern: “aaaab”<br>每次都对比到第 n 位才发现不相等，后移一 位后又从第一位开始比对，因此可以创造 一种算法，先对 pattern 字符串进行预处理，标记上前缀与后缀相等的长度，之后再进行比对时，当比对到不相等的位置时，由于已知前缀与后缀相等的长度，因此可以跳过这一段，比对之后的串即可。</p>
<p>例子中， 当比对第 1 位时，</p>
<table>
<thead>
<tr>
<th>pos</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
</tr>
</thead>
<tbody><tr>
<td>text</td>
<td>a</td>
<td>a</td>
<td>a</td>
<td>a</td>
<td>a</td>
<td>a</td>
<td>a</td>
<td>a</td>
<td>a</td>
<td>b</td>
</tr>
<tr>
<td>pattern</td>
<td>a</td>
<td>a</td>
<td>a</td>
<td>a</td>
<td>b</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>前 4 位都相等，到了第 5 位时不相等，而对 pattern 串，除去不相等的第 5 位，前 4 位中的前缀与后缀的相等长度为 2（1, 2与 3, 4相等），而经过比比对，3, 4 位已经与 text 对应相等，因此可以把第 1, 2 位直接移到此位置即可，减少无效比对。</p>
<table>
<thead>
<tr>
<th>pos</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
</tr>
</thead>
<tbody><tr>
<td>text</td>
<td>a</td>
<td>a</td>
<td>a</td>
<td>a</td>
<td>a</td>
<td>a</td>
<td>a</td>
<td>a</td>
<td>a</td>
<td>b</td>
</tr>
<tr>
<td>pattern</td>
<td></td>
<td></td>
<td>a</td>
<td>a</td>
<td>a</td>
<td>a</td>
<td>b</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="做法-1"><a href="#做法-1" class="headerlink" title="做法"></a>做法</h2><ol>
<li><p>对 pattern 进行预处理得到 pattern 的前缀表 prefix table</p>
<p>逐位判断前后缀相等长度，保存在 prefix 数组</p>
<p>将 prefix 数组整体后移 1 位，prefix[0] &#x3D; -1</p>
</li>
<li><p>KMP<br>两串相等继续；不相等则将 pattern 的指针 j 指向 pattern[j]</p>
</li>
</ol>
<h2 id="复杂度-·-O-m-n"><a href="#复杂度-·-O-m-n" class="headerlink" title="复杂度 · O(m + n)"></a>复杂度 · O(m + n)</h2><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRTSECURE_NOWARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:4996)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_LEN = <span class="number">10000017</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> lenpattern, lentext;</span><br><span class="line"><span class="type">char</span> pattern[MAX_LEN];</span><br><span class="line"><span class="type">char</span> text[MAX_LEN];</span><br><span class="line"><span class="type">int</span> prefix[MAX_LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prefix_table</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	prefix[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; lenpattern)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (pattern[i] == pattern[len])</span><br><span class="line">		&#123;</span><br><span class="line">			len++;</span><br><span class="line">			prefix[i] = len;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (len &gt; <span class="number">0</span>) len = prefix[len - <span class="number">1</span>];</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				prefix[i] = len;</span><br><span class="line">				i++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">move_prefix_table</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = lenpattern - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) prefix[i] = prefix[i - <span class="number">1</span>];</span><br><span class="line">	prefix[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">kmp_search</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">prefix_table</span>();</span><br><span class="line">	<span class="built_in">move_prefix_table</span>();</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; lentext)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (j == lenpattern - <span class="number">1</span> &amp;&amp; text[i] == pattern[j])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;Found pattern at %d\n&quot;</span>, i - j);</span><br><span class="line">			j = prefix[j];</span><br><span class="line">			<span class="keyword">if</span> (j == <span class="number">-1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				i++;</span><br><span class="line">				j++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (text[i] == pattern[j])</span><br><span class="line">			&#123;</span><br><span class="line">				i++;</span><br><span class="line">				j++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				j = prefix[j];</span><br><span class="line">				<span class="keyword">if</span> (j == <span class="number">-1</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					i++;</span><br><span class="line">					j++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, text);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, pattern);</span><br><span class="line">	lentext = <span class="built_in">strlen</span>(text);</span><br><span class="line">	lenpattern = <span class="built_in">strlen</span>(pattern);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">kmp_search</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>text: 目标字符串</p>
<p>pattern: 匹配字符串</p>
<h2 id="101466E-·-Text-Editor"><a href="#101466E-·-Text-Editor" class="headerlink" title="101466E · Text Editor"></a><a target="_blank" rel="noopener" href="https://codeforces.com/gym/101466/problem/E">101466E · Text Editor</a></h2><p>time limit per test: 1 second</p>
<p>memory limit per test: 512 megabytes</p>
<p>input: standard input</p>
<p>output: standard output</p>
<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>One of the most useful tools nowadays are text editors, their use is so important that the Unique Natural Advanced Language (UNAL) organization has studied many of the benefits working with them.</p>
<p>They are interested specifically in the feature “find”, that option looks when a pattern occurs in a text, furthermore, it counts the number of times the pattern occurs in a text. The tool is so well designed that while writing each character of the pattern it updates the number of times that the corresponding prefix of the total pattern appears on the text.</p>
<p>Now the UNAL is working with the editor, finding patterns in some texts, however, they realize that many of the patterns appear just very few times in the corresponding texts, as they really want to see more number of appearances of the patterns in the texts, they put a lower bound on the minimum number of times the pattern should be found in the text and use only prefixes of the original pattern. On the other hand, the UNAL is very picky about language, so they will just use the largest non-empty prefix of the original pattern that fit into the bound.</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line contains the text <em>A</em> (1 ≤ |<em>A</em>| ≤  10<sup>5</sup>) The second line contains the original pattern <em>B</em> (1 ≤ |<em>B</em>| ≤  |<em>A</em>|) The third line contains an integer <em>n</em> (1 ≤ <em>n</em> ≤  |<em>A</em>|) - the minimum number of times a pattern should be found on the text.</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>A single line, with the prefix of the original pattern used by the UNAL, if there is no such prefix then print “IMPOSSIBLE” (without the quotes)</p>
<h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><h4 id="Input-1"><a href="#Input-1" class="headerlink" title="Input 1"></a>Input 1</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">aaaaa</span><br><span class="line">aaa</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<h4 id="Output-1"><a href="#Output-1" class="headerlink" title="Output 1"></a>Output 1</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aa</span><br></pre></td></tr></table></figure>



<h4 id="Input-2"><a href="#Input-2" class="headerlink" title="Input 2"></a>Input 2</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">programming</span><br><span class="line">unal</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<h4 id="Output-2"><a href="#Output-2" class="headerlink" title="Output 2"></a>Output 2</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IMPOSSIBLE</span><br></pre></td></tr></table></figure>



<h4 id="Input-3"><a href="#Input-3" class="headerlink" title="Input 3"></a>Input 3</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">abracadabra</span><br><span class="line">abra</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<h4 id="Output-3"><a href="#Output-3" class="headerlink" title="Output 3"></a>Output 3</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abra</span><br></pre></td></tr></table></figure>



<h4 id="Input-4"><a href="#Input-4" class="headerlink" title="Input 4"></a>Input 4</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hello World!</span><br><span class="line">H W</span><br><span class="line">5</span><br></pre></td></tr></table></figure>

<h4 id="Output-4"><a href="#Output-4" class="headerlink" title="Output 4"></a>Output 4</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IMPOSSIBLE</span><br></pre></td></tr></table></figure>



<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>把 B 字符串对 A 字符串进行 KMP。</p>
<p>但是如果单纯的从长到短 KMP 的话复杂度为 O(n<sup>2</sup>)，因此要对长度进行二分。</p>
<h3 id="Accepted-Code"><a href="#Accepted-Code" class="headerlink" title="Accepted Code"></a>Accepted Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRTSECURE_NOWARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:4996)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_LEN = <span class="number">10000017</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> lenpattern, lentext;</span><br><span class="line"><span class="type">char</span> pattern[MAX_LEN];</span><br><span class="line"><span class="type">char</span> text[MAX_LEN];</span><br><span class="line"><span class="type">int</span> prefix[MAX_LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prefix_table</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	prefix[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; lenpattern)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (pattern[i] == pattern[len])</span><br><span class="line">		&#123;</span><br><span class="line">			len++;</span><br><span class="line">			prefix[i] = len;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (len &gt; <span class="number">0</span>) len = prefix[len - <span class="number">1</span>];</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				prefix[i] = len;</span><br><span class="line">				i++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">move_prefix_table</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = lenpattern; i &gt; <span class="number">0</span>; i--) prefix[i] = prefix[i - <span class="number">1</span>];</span><br><span class="line">	prefix[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kmp_search</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; lentext)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (j == x - <span class="number">1</span> &amp;&amp; text[i] == pattern[j])</span><br><span class="line">		&#123;</span><br><span class="line">			cnt++;</span><br><span class="line">			j = prefix[j];</span><br><span class="line">			<span class="keyword">if</span> (j == <span class="number">-1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				i++;</span><br><span class="line">				j++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (text[i] == pattern[j])</span><br><span class="line">			&#123;</span><br><span class="line">				i++;</span><br><span class="line">				j++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				j = prefix[j];</span><br><span class="line">				<span class="keyword">if</span> (j == <span class="number">-1</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					i++;</span><br><span class="line">					j++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">gets_s</span>(text);</span><br><span class="line">	<span class="built_in">gets_s</span>(pattern);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	lenpattern = <span class="built_in">strlen</span>(pattern);</span><br><span class="line">	lentext = <span class="built_in">strlen</span>(text);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">prefix_table</span>();</span><br><span class="line">	<span class="built_in">move_prefix_table</span>();</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> l = <span class="number">0</span>, r = lenpattern, mid, ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">kmp_search</span>(mid) &gt;= n)</span><br><span class="line">		&#123;</span><br><span class="line">			ans = mid;</span><br><span class="line">			l = mid + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (ans)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ans; i++) <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, pattern[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;IMPOSSIBLE&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
























































      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/12/2021-4-12-kmp/" data-id="clz6fe7ht001b0lox51xo6uzm" data-title="KMP" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/KMP/" rel="tag">KMP</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-2021-2-21-计算几何" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/02/21/2021-2-21-ji-suan-ji-he/" class="article-date">
  <time class="dt-published" datetime="2021-02-21T01:02:44.000Z" itemprop="datePublished">2021-02-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/ACM/">ACM</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/02/21/2021-2-21-ji-suan-ji-he/">计算几何</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="计算几何"><a href="#计算几何" class="headerlink" title="计算几何"></a>计算几何</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="高精度圆周率"><a href="#高精度圆周率" class="headerlink" title="高精度圆周率"></a>高精度圆周率</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br></pre></td></tr></table></figure>



<h3 id="偏差值"><a href="#偏差值" class="headerlink" title="偏差值"></a>偏差值</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-8</span>;</span><br></pre></td></tr></table></figure>



<h3 id="sgn"><a href="#sgn" class="headerlink" title="sgn"></a>sgn</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sgn</span><span class="params">(<span class="type">double</span> x)</span>	<span class="comment">// 判断x是否等于0</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">fabs</span>(x) &lt; eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> x &lt; <span class="number">0</span> ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="dcmp"><a href="#dcmp" class="headerlink" title="dcmp"></a>dcmp</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">dcmp</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span>	<span class="comment">// 比较两个浮点数，0为相等，-1为小于，1为大于</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">fabs</span>(x - y) &lt; eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> x &lt; y ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="点和向量"><a href="#点和向量" class="headerlink" title="点和向量"></a>点和向量</h2><h3 id="点"><a href="#点" class="headerlink" title="点"></a>点</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">double</span> x, y;</span><br><span class="line">	<span class="built_in">Point</span>() &#123;&#125;</span><br><span class="line">	<span class="built_in">Point</span>(<span class="type">double</span> x, <span class="type">double</span> y) : <span class="built_in">x</span>(x), <span class="built_in">y</span>(y) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="两点间距离"><a href="#两点间距离" class="headerlink" title="两点间距离"></a>两点间距离</h3><p>1. </p>
   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">Dist</span><span class="params">(Point A, Point B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">hypot</span>(A.x - B.x, A.y - B.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2. </p>
   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">Dist</span><span class="params">(Point A, Point B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sqrt</span>((A.x - B.x) * (A.x - B.x) + (A.y - B.y) * (A.y - B.y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Point Vector;</span><br></pre></td></tr></table></figure>



<h3 id="向量的运算"><a href="#向量的运算" class="headerlink" title="向量的运算"></a>向量的运算</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">double</span> x, y;</span><br><span class="line">	<span class="built_in">Point</span>() &#123;&#125;</span><br><span class="line">	<span class="built_in">Point</span>(<span class="type">double</span> x, <span class="type">double</span> y) : <span class="built_in">x</span>(x), <span class="built_in">y</span>(y) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	Point <span class="keyword">operator</span>+(Point B) &#123; <span class="keyword">return</span> <span class="built_in">Point</span>(x + B.x, y + B.y); &#125;	<span class="comment">// 加</span></span><br><span class="line"></span><br><span class="line">	Point <span class="keyword">operator</span>-(Point B) &#123; <span class="keyword">return</span> <span class="built_in">Point</span>(x - B.x, y - B.y); &#125;	<span class="comment">// 减</span></span><br><span class="line"></span><br><span class="line">	Point <span class="keyword">operator</span>*(<span class="type">double</span> k) &#123; <span class="keyword">return</span> <span class="built_in">Point</span>(x * k, y * k); &#125;	<span class="comment">// 乘</span></span><br><span class="line"></span><br><span class="line">	Point <span class="keyword">operator</span>/(<span class="type">double</span> k) &#123; <span class="keyword">return</span> <span class="built_in">Point</span>(x / k, y / k); &#125;	<span class="comment">// 除</span></span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>==(Point B) &#123; <span class="keyword">return</span> <span class="built_in">sgn</span>(x - B.x) == <span class="number">0</span> &amp;&amp; <span class="built_in">sgn</span>(y - B.y) == <span class="number">0</span>; &#125;	<span class="comment">// 等于</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h2 id="点积"><a href="#点积" class="headerlink" title="点积"></a>点积</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><code>A · B = |A||B|cosθ</code></p>
<h3 id="几何定义"><a href="#几何定义" class="headerlink" title="几何定义"></a>几何定义</h3><p>θ: 表示向量 b 与向量 a 的夹角</p>
<p>向量 b 在向量 a 上的投影长度乘以向量 a 的模长</p>
<h3 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h3><p><code>A · B = A.x * B.x + A.y * B.y</code></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">Dot</span><span class="params">(Vector A, Vector B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> A.x * B.x + A.y * B.y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ol>
<li><p>判断向量 A 与向量 B 的夹角是钝角还是锐角</p>
<ul>
<li>若 Dot(A, B) &gt; 0: 向量 A 与向量 B 的夹角为锐角</li>
<li>若 Dot(A, B) &lt; 0: 向量 A 与向量 B 的夹角为顿角</li>
<li>若 Dot(A, B) &#x3D; 0: 向量 A 与向量 B 的夹角为直角</li>
</ul>
</li>
<li><p>求向量 A 的模长</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">Len</span><span class="params">(Vector A)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">Dot</span>(A, A));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>求向量 A 与向量 B 的夹角大小</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">Angle</span><span class="params">(Vector A, Vector B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">acos</span>(<span class="built_in">Dot</span>(A, B) / <span class="built_in">Len</span>(A) / <span class="built_in">Len</span>(B));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="叉积"><a href="#叉积" class="headerlink" title="叉积"></a>叉积</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p><code>A × B = |A||B|sinθ</code></p>
<h3 id="几何意义"><a href="#几何意义" class="headerlink" title="几何意义"></a>几何意义</h3><p>θ: 向量 A 旋转到向量 B 所经过的夹角</p>
<p>|A × B| 在数值上等于由向量和向量构成的平行四边形的面积</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">Cross</span><span class="params">(Vector A, Vector B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> A.x * B.y - A.y * B.x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h3><ol>
<li><p>判断向量与向量的方向关系</p>
<ul>
<li>若 A × B &gt; 0，B 在 A 的逆时针方向</li>
<li>若 A × B &lt; 0，B 在 A 的顺时针方向</li>
<li>若 A × B &#x3D; 0，B 与 A 共线，可能是同方向，也可能是反方向</li>
</ul>
</li>
<li><p>计算两向量构成的平行四边形的有向面积</p>
<p>3 个点 A, B, C 以 A 为公共点，得到两个向量 B - A, C - A 它们构成的平行四边形的面积如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">Area2</span><span class="params">(Point A, Point B, Point C)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Cross</span>(B - A, C - A);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同理 Area2(A, B, C) &#x2F; 2 就是计算以 A, B, C 三点构成三角形的面积</p>
</li>
<li><p>向量旋转</p>
<p>向量 A 逆时针旋转的角度为 rad</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vector <span class="title">Rotate</span><span class="params">(Vector A, <span class="type">double</span> rad)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Vector</span>(A.x * <span class="built_in">cos</span>(rad) - A.y * <span class="built_in">sin</span>(rad), A.x * <span class="built_in">sin</span>(rad) + A.y * <span class="built_in">cos</span>(rad));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有时需要求单位法向量，即逆时针旋转 90°，然后取单位值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vector <span class="title">Normal</span><span class="params">(Vector A)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Vector</span>(-A.y / <span class="built_in">Len</span>(A), A.x / <span class="built_in">Len</span>(A));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>用叉积检查两个向量是否平行或重合</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Parallel</span><span class="params">(Vector A, Vector B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sgn</span>(<span class="built_in">Cross</span>(A, B)) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="点和线"><a href="#点和线" class="headerlink" title="点和线"></a>点和线</h2><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Line</span>	<span class="comment">// 直线</span></span><br><span class="line">&#123;</span><br><span class="line">	Point p1, p2;	<span class="comment">// 线上的两个点</span></span><br><span class="line">	<span class="built_in">Line</span>() &#123;&#125;</span><br><span class="line">	<span class="comment">// 直接用两个点来构造直线</span></span><br><span class="line">	<span class="built_in">Line</span>(Point p1, Point p2) : <span class="built_in">p1</span>(p1), <span class="built_in">p2</span>(p2) &#123;&#125;</span><br><span class="line">	<span class="comment">// 根据一个点和倾斜角angle确定直线，0≤angle≤pi</span></span><br><span class="line">	<span class="built_in">Line</span>(Point p, <span class="type">double</span> angle)</span><br><span class="line">	&#123;</span><br><span class="line">		p1 = p;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">sgn</span>(angle - pi / <span class="number">2</span>) == <span class="number">0</span>)</span><br><span class="line">			p2 = (p1 + <span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			p2 = (p1 + <span class="built_in">Point</span>(<span class="number">1</span>, <span class="built_in">tan</span>(angle)));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ax + by + c = 0</span></span><br><span class="line">	<span class="built_in">Line</span>(<span class="type">double</span> a, <span class="type">double</span> b, <span class="type">double</span> c)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">sgn</span>(a) == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			p1 = <span class="built_in">Point</span>(<span class="number">0</span>, -c / b);</span><br><span class="line">			p2 = <span class="built_in">Point</span>(<span class="number">1</span>, -c / b);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">sgn</span>(b) == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			p1 = <span class="built_in">Point</span>(-c / a, <span class="number">0</span>);</span><br><span class="line">			p2 = <span class="built_in">Point</span>(-c / a, <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			p1 = <span class="built_in">Point</span>(<span class="number">0</span>, -c / b);</span><br><span class="line">			p2 = <span class="built_in">Point</span>(<span class="number">1</span>, (-c - a) / b);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="线段的表示"><a href="#线段的表示" class="headerlink" title="线段的表示"></a>线段的表示</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Line Segment;</span><br></pre></td></tr></table></figure>



<h3 id="点和直线的位置关系"><a href="#点和直线的位置关系" class="headerlink" title="点和直线的位置关系"></a>点和直线的位置关系</h3><p>用直线 v 上的两点 p1 和 p2 与点 p 构成两个向量，用叉积的正负判断方向，得到相对的位置关系点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Point_line_relation</span><span class="params">(Point p, Line v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> c = <span class="built_in">sgn</span>(<span class="built_in">Cross</span>(p - v.p1, v.p2 - v.p1));</span><br><span class="line">	<span class="keyword">if</span> (c &lt; <span class="number">0</span>) <span class="comment">// 1：p在v的左边</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (c &gt; <span class="number">0</span>) <span class="comment">// 2：p在v的右边</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 0：p在v上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="点和线段的位置关系"><a href="#点和线段的位置关系" class="headerlink" title="点和线段的位置关系"></a>点和线段的位置关系</h3><p>判断点 p 是否在线段 v 上，先用叉积判断是否共线，然后用点积看 p 和 v 的两个端点产生的角是否为钝角</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Point_on_seg</span><span class="params">(Point p, Line v)</span>	<span class="comment">// 0为点不在线段v上；1为点在线段v上</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sgn</span>(<span class="built_in">Cross</span>(p - v.p1, v.p2 - v.p1)) == <span class="number">0</span> &amp;&amp; <span class="built_in">sgn</span>(<span class="built_in">Dot</span>(p - v.p1, p - v.p2)) &lt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="点到直线的距离"><a href="#点到直线的距离" class="headerlink" title="点到直线的距离"></a>点到直线的距离</h3><p>已知点 p 和直线 v(p1, p2)，求 p 到 v 的距离。首先用叉积求 p, p1, p2 构成的平行四边形的面积，然后用面积除以平行四边形的底边长，也就是线段 (p1, p2) 的长度，就得到了平行四边形的高，即点 p 到直线 v 的距离</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">Dis_point_line</span><span class="params">(Point p, Line v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">fabs</span>(<span class="built_in">Cross</span>(p - v.p1, v.p2 - v.p1)) / <span class="built_in">Dist</span>(v.p1, v.p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="点在直线上的投影"><a href="#点在直线上的投影" class="headerlink" title="点在直线上的投影"></a>点在直线上的投影</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Point <span class="title">Point_line_proj</span><span class="params">(Point p, Line v)</span>	<span class="comment">// 点p在直线v上的投影</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">double</span> k = <span class="built_in">Dot</span>(v.p2 - v.p1, p - v.p1) / <span class="built_in">Len2</span>(v.p2 - v.p1);</span><br><span class="line">	<span class="keyword">return</span> v.p1 + (v.p2 - v.p1) * k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="点关于直线的对称点"><a href="#点关于直线的对称点" class="headerlink" title="点关于直线的对称点"></a>点关于直线的对称点</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Point <span class="title">Point_line_symmetry</span><span class="params">(Point p, Line v)</span>	<span class="comment">// 点p关于直线v的对称点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Point q = <span class="built_in">Point_line_proj</span>(p, v);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Point</span>(<span class="number">2</span> * q.x - p.x, <span class="number">2</span> * q.y - p.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="点到线段的距离"><a href="#点到线段的距离" class="headerlink" title="点到线段的距离"></a>点到线段的距离</h3><p>对于点 p 到线段 v(p1, p2) 的距离，在以下 3 个距离中取最小值：从 p 出发对线段 v 做垂线，如果交点在 v 上，这个距离就是最小值；p 到 p1 的距离，p 到 p2 的距离</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">Dis_point_seg</span><span class="params">(Point p, Segment v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">sgn</span>(<span class="built_in">Dot</span>(p - v.p1, v.p2 - v.p1)) &lt; <span class="number">0</span> || <span class="built_in">sgn</span>(<span class="built_in">Dot</span>(p - v.p2, v.p1 - v.p2)) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">min</span>(<span class="built_in">Dist</span>(p, v.p1), <span class="built_in">Dist</span>(p, v.p2));</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Dis_point_line</span>(p, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="两条直线的位置关系"><a href="#两条直线的位置关系" class="headerlink" title="两条直线的位置关系"></a>两条直线的位置关系</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Line_relation</span><span class="params">(Line v1, Line v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">sgn</span>(<span class="built_in">Cross</span>(v<span class="number">1.</span>p2 - v<span class="number">1.</span>p1, v<span class="number">2.</span>p2 - v<span class="number">2.</span>p1)) == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">Point_line_relation</span>(v<span class="number">1.</span>p1, v2) == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 1：重合</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 0：平行</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">2</span>; <span class="comment">// 2：相交</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="求两条直线的交点"><a href="#求两条直线的交点" class="headerlink" title="求两条直线的交点"></a>求两条直线的交点</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Point <span class="title">Cross_point</span><span class="params">(Point a, Point b, Point c, Point d)</span>	<span class="comment">// Line: ab, Line: cd</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">double</span> s1 = <span class="built_in">Cross</span>(b - a, c - a);</span><br><span class="line">	<span class="type">double</span> s2 = <span class="built_in">Cross</span>(b - a, d - a);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Point</span>(c.x * s2 - d.x * s1, c.y * s2 - d.y * s1) / (s2 - s1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="判断两个线段是否规范相交"><a href="#判断两个线段是否规范相交" class="headerlink" title="判断两个线段是否规范相交"></a>判断两个线段是否规范相交</h3><p>这里利用叉积有正负的特点。如果一条线段的两端在另一条线段的两侧，那么两个端点与另一线段产生的两个叉积的正负相反，也就是说两个叉积相乘为负。如果两条线段互相满足这一点，那么就是规范相交的。</p>
<p>规范相交：交点在线段内部</p>
<p>非规范相交：交点在某条线段的端点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Cross_segment</span><span class="params">(Point a, Point b, Point c, Point d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 规范相交</span></span><br><span class="line">	<span class="type">double</span> c1 = <span class="built_in">Cross</span>(b - a, c - a), c2 = <span class="built_in">Cross</span>(b - a, d - a);</span><br><span class="line">	<span class="type">double</span> d1 = <span class="built_in">Cross</span>(d - c, a - c), d2 = <span class="built_in">Cross</span>(d - c, b - c);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sgn</span>(c1) * <span class="built_in">sgn</span>(c2) &lt; <span class="number">0</span> &amp;&amp; <span class="built_in">sgn</span>(d1) * <span class="built_in">sgn</span>(d2) &lt; <span class="number">0</span>; <span class="comment">// 1: 相交，0: 不相交</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 非规范相交</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">max</span>(a.x, b.x) &gt;= <span class="built_in">min</span>(c.x, d.x) &amp;&amp; <span class="built_in">max</span>(c.x, d.x) &gt;= <span class="built_in">min</span>(a.x, b.x) &amp;&amp; <span class="built_in">max</span>(a.y, b.y) &gt;= <span class="built_in">min</span>(c.y, d.y) &amp;&amp; <span class="built_in">max</span>(c.y, d.y) &gt;= <span class="built_in">min</span>(a.y, b.y) &amp;&amp; <span class="built_in">sgn</span>(<span class="built_in">Cross</span>(b - a, c - a)) * <span class="built_in">sgn</span>(<span class="built_in">Cross</span>(b - a, d - a)) &lt;= <span class="number">0</span> &amp;&amp; <span class="built_in">sgn</span>(<span class="built_in">Cross</span>(d - c, a - c)) * <span class="built_in">sgn</span>(<span class="built_in">Cross</span>(d - c, b - c)) &lt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="多边形"><a href="#多边形" class="headerlink" title="多边形"></a>多边形</h2><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point p[N];</span><br></pre></td></tr></table></figure>



<h3 id="应用-2"><a href="#应用-2" class="headerlink" title="应用"></a>应用</h3><ol>
<li><p>判断点是否在多边形内部</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Point_in_polygon</span><span class="params">(Point pt, Point* p, <span class="type">int</span> n)</span>	<span class="comment">// 点pt，多边形Point* p</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">		<span class="keyword">if</span> (p[i] == pt)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">3</span>;	<span class="comment">// 3: 点在多边形的顶点上</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		Line v = <span class="built_in">Line</span>(p[i], p[(i + <span class="number">1</span>) % n]);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">Point_on_seg</span>(pt, v))</span><br><span class="line">			<span class="keyword">return</span> <span class="number">2</span>;	<span class="comment">// 2: 点在多边形的边上</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> j = (i + <span class="number">1</span>) % n;</span><br><span class="line">		<span class="type">int</span> c = <span class="built_in">sgn</span>(<span class="built_in">Cross</span>(pt - p[j], p[i] - p[j]));</span><br><span class="line">		<span class="type">int</span> u = <span class="built_in">sgn</span>(p[i].y - pt.y);</span><br><span class="line">		<span class="type">int</span> v = <span class="built_in">sgn</span>(p[j].y - pt.y);</span><br><span class="line">		<span class="keyword">if</span> (c &gt; <span class="number">0</span> &amp;&amp; u &lt; <span class="number">0</span> &amp;&amp; v &gt;= <span class="number">0</span>)</span><br><span class="line">			++num;</span><br><span class="line">		<span class="keyword">if</span> (c &lt; <span class="number">0</span> &amp;&amp; u &gt;= <span class="number">0</span> &amp;&amp; v &lt; <span class="number">0</span>)</span><br><span class="line">			--num;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> num != <span class="number">0</span>;	<span class="comment">// 1: 点在内部；0: 点在外部</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>多边形的面积</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">Polygon_area</span><span class="params">(Point* p, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">double</span> area = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">		area += <span class="built_in">Cross</span>(p[i], p[(i + <span class="number">1</span>) % n]);</span><br><span class="line">	<span class="keyword">return</span> area / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>求多边形的重心</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Point <span class="title">Polygon_center</span><span class="params">(Point* p, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Point <span class="title">ans</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">Polygon_area</span>(p, n) == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">		ans = ans + (p[i] + p[(i + <span class="number">1</span>) % n]) * <span class="built_in">Cross</span>(p[i], p[(i + <span class="number">1</span>) % n]);</span><br><span class="line">	<span class="keyword">return</span> ans / <span class="built_in">Polygon_area</span>(p, n) / <span class="number">6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="凸包"><a href="#凸包" class="headerlink" title="凸包"></a>凸包</h3><p>凸多边形：所有内角大小都在 $[0, \ \pi]$ 范围内的 <strong>简单多边形</strong>。</p>
<p>凸包：在平面上能包含所有给定点的最小凸多边形叫做凸包。</p>
<p>定义：对于给定集合 X，所有包含 X 的凸集的交集 S 被称为 X 的 <strong>凸包</strong>。</p>
<p><img src="/Users/owlllovo/Documents/IMG_9302.jpg" alt="IMG_9302"></p>
<p>凸包用最小的周长围住了给定的所有点。如果一个凹多边形围住了所有的点，它的周长一定不是最小，如下图。根据三角不等式，凸多边形在周长上一定是最优的。</p>
<h4 id="求法"><a href="#求法" class="headerlink" title="求法"></a>求法</h4><p>常用的求法有 Graham 扫描法和 Andrew 算法，这里主要介绍 Andrew 算法。</p>
<h5 id="Andrew"><a href="#Andrew" class="headerlink" title="Andrew"></a>Andrew</h5><p>该算法的时间复杂度为 $O(n \log n)$，其中 n 为待求凸包点集的大小，同时复杂度的瓶颈也在于对所有点坐标的双关键字排序。</p>
<p>首先把所有点以横坐标为第一关键字，纵坐标为第二关键字排序。</p>
<p>显然排序后最小的元素和最大的元素一定在凸包上。而且因为是凸多边形，我们如果从一个点出发逆时针走，轨迹总是“左拐”的，一旦出现右拐，就说明这一段不在凸包上。因此我们可以用一个单调栈来维护上下凸壳。</p>
<p>因为从左向右看，上下凸壳所旋转的方向不同，为了让单调栈起作用，我们首先 <strong>升序枚举</strong> 求出下凸壳，然后 <strong>降序</strong> 求出上凸壳。</p>
<p>求凸壳时，一旦发现即将进栈的点（P）和栈顶的两个点（$S_{1}, \ S_{2}$，其中 $S_{1}$ 为栈顶）行进的方向向右旋转，即叉积小于 0：$\overrightarrow{S_{2}S_{1}} \ \times \ \overrightarrow{S_{1}P} \ &lt; \ 0$，则弹出栈顶，回到上一步，继续检测，直到 $\overrightarrow{S_{2}S_{1}} \ \times \ \overrightarrow{S_{1}P} \ \geq \ 0$ 或者栈内仅剩一个元素为止。</p>
<p>通常情况下不需要保留位于凸包边上的点，因此上面一段中 $\overrightarrow{S_{2}S_{1}} \ \times \ \overrightarrow{S_{1}P} \ &lt; \ 0$ 这个条件中的 $&lt;$ 可以视情况改为 $\leq$，同时后面一个条件应改为 $&gt;$。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stk[] 是整型，存的是下标</span></span><br><span class="line"><span class="comment">// p[] 存储向量或点</span></span><br><span class="line">tp = <span class="number">0</span>;                       <span class="comment">// 初始化栈</span></span><br><span class="line">std::<span class="built_in">sort</span>(p + <span class="number">1</span>, p + <span class="number">1</span> + n);  <span class="comment">// 对点进行排序</span></span><br><span class="line">stk[++tp] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//栈内添加第一个元素，且不更新 used，使得 1 在最后封闭凸包时也对单调栈更新</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span> (tp &gt;= <span class="number">2</span> &amp;&amp; (p[stk[tp]] - p[stk[tp - <span class="number">1</span>]]) * (p[i] - p[stk[tp]]) &lt;= <span class="number">0</span>)	<span class="comment">// * 操作符被重载为叉积</span></span><br><span class="line">		used[stk[tp--]] = <span class="number">0</span>;</span><br><span class="line">	used[i] = <span class="number">1</span>;  <span class="comment">// used 表示在凸壳上</span></span><br><span class="line">	stk[++tp] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> tmp = tp;  <span class="comment">// tmp 表示下凸壳大小</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i)</span><br><span class="line"><span class="keyword">if</span> (!used[i])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//      ↓求上凸壳时不影响下凸壳</span></span><br><span class="line">	<span class="keyword">while</span> (tp &gt; tmp &amp;&amp; (p[stk[tp]] - p[stk[tp - <span class="number">1</span>]]) * (p[i] - p[stk[tp]]) &lt;= <span class="number">0</span>)</span><br><span class="line">		used[stk[tp--]] = <span class="number">0</span>;</span><br><span class="line">	used[i] = <span class="number">1</span>;</span><br><span class="line">	stk[++tp] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tp; ++i)  <span class="comment">// 复制到新数组中去</span></span><br><span class="line">h[i] = p[stk[i]];</span><br><span class="line"><span class="type">int</span> ans = tp - <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>根据上面的代码，最后凸包上有 ans 个元素（额外存储了 1 号点，因此 h 数组中有 ans + 1 个元素），并且按逆时针方向排序。周长就是 $\sum_{i&#x3D;1}^{ans}|\overrightarrow{h_{i}h_{i+1}}|$</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/02/21/2021-2-21-ji-suan-ji-he/" data-id="clz6fe7hr000z0lox4lg83bm2" data-title="计算几何" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/" rel="tag">计算几何</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-2021-2-20-博弈论" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/02/20/2021-2-20-bo-yi-lun/" class="article-date">
  <time class="dt-published" datetime="2021-02-20T01:02:55.000Z" itemprop="datePublished">2021-02-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/ACM/">ACM</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/02/20/2021-2-20-bo-yi-lun/">博弈论</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="博弈论"><a href="#博弈论" class="headerlink" title="博弈论"></a>博弈论</h1><h2 id="巴什博弈"><a href="#巴什博弈" class="headerlink" title="巴什博弈"></a>巴什博弈</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>一堆物品有 n 个，两个人轮流从这堆物品中取物，规定每次可以取走 1 ~ m 个，最后取光者得胜。</p>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>显然，如果 n &#x3D; m + 1，那么由于一次最多只能取 m 个，所以，无论先取者拿走多少个，后取者都能够一次拿走剩余的物品，后者取胜。因此我们发现了如何取胜的法则：如果 n &#x3D; (m + 1) r + s，（r 为任意自然数，s ≤ m），那么先取者要拿走 s 个物品，如果后取者拿走 k(≤ m) 个，那么先取者再拿走 m + 1 - k 个，结果剩下 (m + 1)(r - 1) 个，以后保持这样的取法，那么先取者肯定获胜。总之，要保持给对手留下 (m + 1) 的倍数，就能最后获胜。</p>
<h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRTSECURE_NOWARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:4996)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> C, n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">if</span> (n % (m + <span class="number">1</span>)) <span class="built_in">printf</span>(<span class="string">&quot;first\n&quot;</span>);	<span class="comment">//先手胜</span></span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;second\n&quot;</span>);	<span class="comment">//后手胜</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Brave-Game"><a href="#Brave-Game" class="headerlink" title="Brave Game"></a><a target="_blank" rel="noopener" href="http://acm.hdu.edu.cn/showproblem.php?pid=1846">Brave Game</a></h3><p>巴什博弈模板题</p>
<h3 id="Good-Luck-in-CET-4-Everybody"><a href="#Good-Luck-in-CET-4-Everybody" class="headerlink" title="Good Luck in CET-4 Everybody!"></a><a target="_blank" rel="noopener" href="http://acm.hdu.edu.cn/showproblem.php?pid=1847">Good Luck in CET-4 Everybody!</a></h3><h4 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h4><p>大学英语四级考试就要来临了，你是不是在紧张的复习？也许紧张得连短学期的 ACM 都没工夫练习了，反正我知道的 Kiki 和 Cici 都是如此。当然，作为在考场浸润了十几载的当代大学生，Kiki 和 Cici 更懂得考前的放松，所谓“张弛有道”就是这个意思。这不，Kiki 和 Cici 在每天晚上休息之前都要玩一会儿扑克牌以放松神经。</p>
<p>“升级”？“双扣”？“红五”？还是“斗地主”？</p>
<p>当然都不是！那多俗啊~</p>
<p>作为计算机学院的学生，Kiki 和 Cici 打牌的时候可没忘记专业，她们打牌的规则是这样的：</p>
<ol>
<li>总共n张牌;</li>
<li>双方轮流抓牌；</li>
<li>每人每次抓牌的个数只能是2的幂次（即：1，2，4，8，16…）</li>
<li>抓完牌，胜负结果也出来了：最后抓完牌的人为胜者；</li>
</ol>
<p>假设 Kiki 和 Cici 都是足够聪明（其实不用假设，哪有不聪明的学生~），并且每次都是 Kiki 先抓牌，请问谁能赢呢？</p>
<p>当然，打牌无论谁赢都问题不大，重要的是马上到来的 CET-4 能有好的状态。</p>
<p>Good luck in CET-4 everybody!</p>
<h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><p>输入数据包含多个测试用例，每个测试用例占一行，包含一个整数 n（1&lt;&#x3D;n&lt;&#x3D;1000）。 </p>
<h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><p>如果 Kiki 能赢的话，请输出 “Kiki”，否则请输出 “Cici”，每个实例的输出占一行。 </p>
<h4 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">3 </span><br></pre></td></tr></table></figure>



<h4 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Kiki</span><br><span class="line">Cici</span><br></pre></td></tr></table></figure>



<h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>如果你是先手，那么请考虑你的必胜点。由于规定只能去 2 的幂次，那么只要你留给对手的牌数为 3 的倍数时，那么你就必赢，因为留下 3 的倍数时，对手有两种情况：</p>
<ol>
<li>要么取剩下 1，给你胜利</li>
<li>要么对手取了一点点儿，轮到你时，你就又可以构造一个 3 的倍数了嘛。</li>
</ol>
<p>所以无论哪种情况，当你留给对手为 3N 的时候，你是必胜的。好吧，题目说你就是 Kiki，那么当牌数为 3 的倍数时，Kiki 就输了。因为一出来，上帝就留给了 Kiki 一个 3 的倍数。没办法，但是如果一开始上帝留给 Kiki 的不是 3 的倍数，那么 Kiki 肯定能够用先手的优势构造出 3 的倍数，那么 Kiki 就必胜。所以代码是异常的简单啊。</p>
<h4 id="Accepted-Code"><a href="#Accepted-Code" class="headerlink" title="Accepted Code"></a>Accepted Code</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRTSECURE_NOWARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:4996)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n) != EOF)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!(n % <span class="number">3</span>)) <span class="built_in">printf</span>(<span class="string">&quot;Cici\n&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;Kiki\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/02/20/2021-2-20-bo-yi-lun/" data-id="clz6fe7hs00120loxadn562jh" data-title="博弈论" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/" rel="tag">博弈论</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-2021-2-4-LCA" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/02/04/2021-2-4-lca/" class="article-date">
  <time class="dt-published" datetime="2021-02-04T00:31:40.000Z" itemprop="datePublished">2021-02-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/ACM/">ACM</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/02/04/2021-2-4-lca/">LCA</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="LCA"><a href="#LCA" class="headerlink" title="LCA"></a>LCA</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>对于有根树 T 的两个结点 u、v，最近公共祖先 LCA(T, u, v) 表示一个结点 x，满足 x 是 u 和 v 的祖先且 x 的深度尽可能大。在这里，一个节点也可以是它自己的祖先。</p>
<p>——百度百科</p>
</blockquote>
<p>记某点集 $S \ &#x3D; \ v_{1}, \ v_{2}, \ \cdots, \ v_{n}$ 的最近公共祖先为 $LCA(v_{1}, \ v_{2}, \ \cdots, \ v_{n})$ 或 $LCA(S)$</p>
<h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><ol>
<li>$LCA (u) \ &#x3D; \ u$；</li>
<li>u 是 v 的祖先，当且仅当 $LCA(u, \ v) \ &#x3D; \ u$；</li>
<li>如果 u 不为 v 的祖先并且 v 不为 u 的祖先，那么 u, v 分别处于 $LCA(u, \ v)$ 的两棵不同子树中；</li>
<li>前序遍历中，$LCA(S)$ 出现在所有 S 中元素之前，后序遍历中 LCA(S) 则出现在所有 S 中元素之后；</li>
<li>两点集并的最近公共祖先为两点集分别的最近公共祖先的最近公共祖先，即 $LCA(A \ \cup \ B) \ &#x3D; \ LCA(LCA(A), \ LCA(B))$；</li>
<li>两点的最近公共祖先必定处在树上两点间的最短路上；</li>
<li>$d(u, \ v) \ &#x3D; \ h(u) \ + \ h(v) \ - \ 2h(LCA(u, \ v))$，其中 d 是树上两点间的距离，h 代表某点到树根的距离。</li>
</ol>
<h2 id="求法"><a href="#求法" class="headerlink" title="求法"></a>求法</h2><h3 id="朴素算法"><a href="#朴素算法" class="headerlink" title="朴素算法"></a>朴素算法</h3><p>可以每次找深度比较大的那个点，让它向上跳。显然在树上，这两个点最后一定会相遇，相遇的位置就是想要求的 LCA。 或者先向上调整深度较大的点，令他们深度相同，然后再共同向上跳转，最后也一定会相遇。</p>
<p>朴素算法预处理时需要 dfs 整棵树，时间复杂度为 $O(n)$，单次查询时间复杂度为 $O(n)$。但由于随机树高为 $O(\log n)$，所以朴素算法在随机树上的单次查询时间复杂度为 $O(\log n)$。</p>
<h3 id="倍增算法"><a href="#倍增算法" class="headerlink" title="倍增算法"></a>倍增算法</h3><p>倍增算法是最经典的 LCA 求法，他是朴素算法的改进算法。通过预处理 数组，游标可以快速移动，大幅减少了游标跳转次数。 表示点 的第 个祖先。 数组可以通过 dfs 预处理出来。</p>
<p>现在我们看看如何优化这些跳转： 在调整游标的第一阶段中，我们要将 两点跳转到同一深度。我们可以计算出 两点的深度之差，设其为 。通过将 进行二进制拆分，我们将 次游标跳转优化为「 的二进制表示所含 <code>1</code> 的个数」次游标跳转。 在第二阶段中，我们从最大的 开始循环尝试，一直尝试到 （包括 ），如果 ，则 ，那么最后的 LCA 为 。</p>
<p>倍增算法的预处理时间复杂度为 ，单次查询时间复杂度为 。 另外倍增算法可以通过交换 <code>fa</code> 数组的两维使较小维放在前面。这样可以减少 cache miss 次数，提高程序效率。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MXN 50007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v[MXN];</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; w[MXN];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fa[MXN][<span class="number">31</span>], cost[MXN][<span class="number">31</span>], dep[MXN];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a, b, c;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> root, <span class="type">int</span> fno)</span> </span>&#123;</span><br><span class="line">	fa[root][<span class="number">0</span>] = fno;</span><br><span class="line">	dep[root] = dep[fa[root][<span class="number">0</span>]] + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">31</span>; ++i) &#123;</span><br><span class="line">		fa[root][i] = fa[fa[root][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">		cost[root][i] = cost[fa[root][i - <span class="number">1</span>]][i - <span class="number">1</span>] + cost[root][i - <span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> sz = v[root].<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sz; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (v[root][i] == fno) <span class="keyword">continue</span>;</span><br><span class="line">		cost[v[root][i]][<span class="number">0</span>] = w[root][i];</span><br><span class="line">		<span class="built_in">dfs</span>(v[root][i], root);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (dep[x] &gt; dep[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">	<span class="type">int</span> tmp = dep[y] - dep[x], ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; tmp; ++j, tmp &gt;&gt;= <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">if</span> (tmp &amp; <span class="number">1</span>) ans += cost[y][j], y = fa[y][j];</span><br><span class="line">	<span class="keyword">if</span> (y == x) <span class="keyword">return</span> ans;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">30</span>; j &gt;= <span class="number">0</span> &amp;&amp; y != x; --j) &#123;</span><br><span class="line">		<span class="keyword">if</span> (fa[x][j] != fa[y][j]) &#123;</span><br><span class="line">			ans += cost[x][j] + cost[y][j];</span><br><span class="line">			x = fa[x][j];</span><br><span class="line">			y = fa[y][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ans += cost[x][<span class="number">0</span>] + cost[y][<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(fa, <span class="number">0</span>, <span class="built_in">sizeof</span>(fa));</span><br><span class="line">	<span class="built_in">memset</span>(cost, <span class="number">0</span>, <span class="built_in">sizeof</span>(cost));</span><br><span class="line">	<span class="built_in">memset</span>(dep, <span class="number">0</span>, <span class="built_in">sizeof</span>(dep));</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">		++a, ++b;</span><br><span class="line">		v[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">		v[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">		w[a].<span class="built_in">push_back</span>(c);</span><br><span class="line">		w[b].<span class="built_in">push_back</span>(c);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">		++a, ++b;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">lca</span>(a, b));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="Tarjan-·-离线"><a href="#Tarjan-·-离线" class="headerlink" title="Tarjan · 离线"></a>Tarjan · 离线</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p><code>Tarjan 算法</code> 是一种 <code>离线算法</code>，需要使用 <code>并查集</code> 记录某个结点的祖先结点。做法如下：</p>
<ol>
<li>首先接受输入（邻接链表）、查询（存储在另一个邻接链表内）。查询边其实是虚拟加上去的边，为了方便，每次输入查询边的时候，将这个边及其反向边都加入到 <code>queryEdge</code> 数组里。</li>
<li>然后对其进行一次 DFS 遍历，同时使用 <code>visited</code> 数组进行记录某个结点是否被访问过、<code>parent</code> 记录当前结点的父亲结点。</li>
<li>其中涉及到了 <code>回溯思想</code>，我们每次遍历到某个结点的时候，认为这个结点的根结点就是它本身。让以这个结点为根节点的 DFS 全部遍历完毕了以后，再将 <code>这个结点的根节点</code> 设置为 <code>这个结点的父一级结点</code>。</li>
<li>回溯的时候，如果以该节点为起点，<code>queryEdge</code> 查询边的另一个结点也恰好访问过了，则直接更新查询边的 LCA 结果。</li>
<li>最后输出结果。</li>
</ol>
<p>Tarjan 算法需要初始化并查集，所以预处理的时间复杂度为 $O(n)$，Tarjan 算法处理所有 m 次询问的时间复杂度为 $O(m \ + \ n)$。但是 Tarjan 算法的常数比倍增算法大。</p>
<p>需要注意的是，Tarjan 算法中使用的并查集性质比较特殊，在仅使用路径压缩优化的情况下，单次调用 <code>find()</code> 函数的时间复杂度为均摊 $O(1)$，而不是 $O(\log n)$。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> toVertex, fromVertex;</span><br><span class="line">	<span class="type">int</span> next;</span><br><span class="line">	<span class="type">int</span> LCA;</span><br><span class="line">	<span class="built_in">Edge</span>() : <span class="built_in">toVertex</span>(<span class="number">-1</span>), <span class="built_in">fromVertex</span>(<span class="number">-1</span>), <span class="built_in">next</span>(<span class="number">-1</span>), <span class="built_in">LCA</span>(<span class="number">-1</span>) &#123;&#125;;</span><br><span class="line">	<span class="built_in">Edge</span>(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> n) : <span class="built_in">fromVertex</span>(u), <span class="built_in">toVertex</span>(v), <span class="built_in">next</span>(n), <span class="built_in">LCA</span>(<span class="number">-1</span>) &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> head[MAX], queryHead[MAX];</span><br><span class="line">Edge edge[MAX], queryEdge[MAX];</span><br><span class="line"><span class="type">int</span> parent[MAX], visited[MAX];</span><br><span class="line"><span class="type">int</span> vertexCount, edgeCount, queryCount;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= vertexCount; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		parent[i] = i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (parent[x] == x) &#123;</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">find</span>(parent[x]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">	parent[u] = u;</span><br><span class="line">	visited[u] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = head[u]; i != <span class="number">-1</span>; i = edge[i].next) &#123;</span><br><span class="line">		Edge&amp; e = edge[i];</span><br><span class="line">		<span class="keyword">if</span> (!visited[e.toVertex]) &#123;</span><br><span class="line">			<span class="built_in">tarjan</span>(e.toVertex);</span><br><span class="line">			parent[e.toVertex] = u;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = queryHead[u]; i != <span class="number">-1</span>; i = queryEdge[i].next) &#123;</span><br><span class="line">		Edge&amp; e = queryEdge[i];</span><br><span class="line">		<span class="keyword">if</span> (visited[e.toVertex]) &#123;</span><br><span class="line">			queryEdge[i ^ <span class="number">1</span>].LCA = e.LCA = <span class="built_in">find</span>(e.toVertex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(head, <span class="number">0xff</span>, <span class="built_in">sizeof</span>(head));</span><br><span class="line">	<span class="built_in">memset</span>(queryHead, <span class="number">0xff</span>, <span class="built_in">sizeof</span>(queryHead));</span><br><span class="line"></span><br><span class="line">	cin &gt;&gt; vertexCount &gt;&gt; edgeCount &gt;&gt; queryCount;</span><br><span class="line">	<span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; edgeCount; i++) &#123;</span><br><span class="line">		<span class="type">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">		cin &gt;&gt; start &gt;&gt; end;</span><br><span class="line"></span><br><span class="line">		edge[count] = <span class="built_in">Edge</span>(start, end, head[start]);</span><br><span class="line">		head[start] = count;</span><br><span class="line">		count++;</span><br><span class="line"></span><br><span class="line">		edge[count] = <span class="built_in">Edge</span>(end, start, head[end]);</span><br><span class="line">		head[end] = count;</span><br><span class="line">		count++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; queryCount; i++) &#123;</span><br><span class="line">		<span class="type">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">		cin &gt;&gt; start &gt;&gt; end;</span><br><span class="line"></span><br><span class="line">		queryEdge[count] = <span class="built_in">Edge</span>(start, end, queryHead[start]);</span><br><span class="line">		queryHead[start] = count;</span><br><span class="line">		count++;</span><br><span class="line"></span><br><span class="line">		queryEdge[count] = <span class="built_in">Edge</span>(end, start, queryHead[end]);</span><br><span class="line">		queryHead[end] = count;</span><br><span class="line">		count++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">init</span>();</span><br><span class="line">	<span class="built_in">tarjan</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; queryCount; i++) &#123;</span><br><span class="line">		Edge&amp; e = queryEdge[i * <span class="number">2</span>];</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; e.fromVertex &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; e.toVertex &lt;&lt; <span class="string">&quot;) &quot;</span> &lt;&lt; e.LCA &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="在线倍增"><a href="#在线倍增" class="headerlink" title="在线倍增"></a>在线倍增</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">5e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, s;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">lca</span> &#123;</span><br><span class="line">	<span class="type">int</span> cnt, head[maxn];</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">edge</span> &#123; <span class="type">int</span> to, next; &#125; e[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">		e[++cnt] = &#123; v, head[u] &#125;; head[u] = cnt;</span><br><span class="line">		e[++cnt] = &#123; u, head[v] &#125;; head[v] = cnt;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> dep[maxn];</span><br><span class="line">	<span class="type">int</span> lg[maxn];</span><br><span class="line">	<span class="type">int</span> fa[maxn][<span class="number">22</span>];</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">			lg[i] = lg[i - <span class="number">1</span>] + (<span class="number">1</span> &lt;&lt; lg[i - <span class="number">1</span>] == i);</span><br><span class="line">			<span class="comment">//		cout &lt;&lt; i &lt;&lt; &quot; -&gt; &quot; &lt;&lt; lg[i] &lt;&lt; endl;</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> now, <span class="type">int</span> pre)</span> </span>&#123;</span><br><span class="line">		fa[now][<span class="number">0</span>] = pre; dep[now] = dep[pre] + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= lg[dep[now]]; ++i)</span><br><span class="line">			fa[now][i] = fa[fa[now][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = head[now]; i; i = e[i].next)</span><br><span class="line">			<span class="keyword">if</span> (e[i].to != pre) <span class="built_in">dfs</span>(e[i].to, now);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">LCA</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (dep[x] &lt; dep[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">		<span class="keyword">while</span> (dep[x] &gt; dep[y]) x = fa[x][lg[dep[x] - dep[y]] - <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span> (x == y) <span class="keyword">return</span> x;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> k = lg[dep[x]] - <span class="number">1</span>; k &gt;= <span class="number">0</span>; --k)</span><br><span class="line">			<span class="keyword">if</span> (fa[x][k] != fa[y][k])</span><br><span class="line">				x = fa[x][k], y = fa[y][k];</span><br><span class="line">		<span class="keyword">return</span> fa[x][<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125; Lca;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;s);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="type">int</span> x, y;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">		Lca.<span class="built_in">add</span>(x, y);</span><br><span class="line">	&#125;</span><br><span class="line">	Lca.<span class="built_in">init</span>();</span><br><span class="line">	Lca.<span class="built_in">dfs</span>(s, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">		<span class="type">int</span> x, y;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, Lca.<span class="built_in">LCA</span>(x, y));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="Tarjan"><a href="#Tarjan" class="headerlink" title="Tarjan"></a>Tarjan</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">5e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, r;</span><br><span class="line"><span class="type">int</span> ans[maxn];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LCA</span> &#123;</span><br><span class="line">	<span class="type">int</span> vis[maxn];</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> s[maxn];</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) s[i] = i; &#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> s[x] == x ? x : s[x] = <span class="built_in">find</span>(s[x]); &#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> tot, first[maxn];</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">query</span> &#123; <span class="type">int</span> to, next; &#125; q[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">		q[++tot] = &#123; y, first[x] &#125;; first[x] = tot;</span><br><span class="line">		q[++tot] = &#123; x, first[y] &#125;; first[y] = tot;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> cnt, head[maxn];</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">edge</span> &#123; <span class="type">int</span> to, next; &#125; e[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">		e[++cnt] = &#123; v, head[u] &#125;; head[u] = cnt;</span><br><span class="line">		e[++cnt] = &#123; u, head[v] &#125;; head[v] = cnt;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Tarjan</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = head[u]; i; i = e[i].next) &#123;</span><br><span class="line">			<span class="keyword">if</span> (e[i].to == fa) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="built_in">Tarjan</span>(e[i].to, u);</span><br><span class="line">			s[e[i].to] = u;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = first[u]; i; i = q[i].next) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!vis[q[i].to]) <span class="keyword">continue</span>;</span><br><span class="line">			ans[(i + <span class="number">1</span>) / <span class="number">2</span>] = <span class="built_in">find</span>(q[i].to);</span><br><span class="line">		&#125;</span><br><span class="line">		vis[u] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; Lca;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;r);</span><br><span class="line">	Lca.<span class="built_in">init</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="type">int</span> x, y;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">		Lca.<span class="built_in">add</span>(x, y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">		<span class="type">int</span> x, y;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">		Lca.<span class="built_in">insert</span>(x, y);</span><br><span class="line">	&#125;</span><br><span class="line">	Lca.<span class="built_in">Tarjan</span>(r, <span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/02/04/2021-2-4-lca/" data-id="clz6fe7hs00180lox69rgfypb" data-title="LCA" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LCA/" rel="tag">LCA</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-2021-2-3-数论" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/02/03/2021-2-3-shu-lun/" class="article-date">
  <time class="dt-published" datetime="2021-02-03T12:00:00.000Z" itemprop="datePublished">2021-02-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/ACM/">ACM</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/02/03/2021-2-3-shu-lun/">2021.2.3</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h1><h2 id="素数"><a href="#素数" class="headerlink" title="素数"></a>素数</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>一个大于 1 的自然数，除了 1 和它自身外，不能被其他自然数整除的数叫做素数；否则称为合数</p>
<ul>
<li>1既不是质数也不是合数</li>
</ul>
<h3 id="判断方法"><a href="#判断方法" class="headerlink" title="判断方法"></a>判断方法</h3><h4 id="暴力-·-O-frac-n-2"><a href="#暴力-·-O-frac-n-2" class="headerlink" title="暴力 · $O(\frac{n}{2})$"></a>暴力 · $O(\frac{n}{2})$</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPrime</span><span class="params">(a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (a &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i * i &lt; a; ++i)</span><br><span class="line">		<span class="keyword">if</span> (!(a % i)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Miller-Rabin-素性测试-·-O-k-log-3-n"><a href="#Miller-Rabin-素性测试-·-O-k-log-3-n" class="headerlink" title="Miller-Rabin 素性测试 · $ O(k \ log^{3}n)$"></a>Miller-Rabin 素性测试 · $ O(k \ log^{3}n)$</h4><h5 id="Fermat-素性测试"><a href="#Fermat-素性测试" class="headerlink" title="Fermat 素性测试"></a>Fermat 素性测试</h5><p>我们可以根据费马小定理得出一种检验素数的思路：</p>
<p>它的基本思想是不断地选取在 [2, n - 1] 中的基 a，并检验是否每次都有 $a^{n - 1} \ \equiv \ 1 \ (mod \ n)$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">millerRabin</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">3</span>) <span class="keyword">return</span> n == <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// test_time 为测试次数,建议设为不小于 8</span></span><br><span class="line">    <span class="comment">// 的整数以保证正确率,但也不宜过大,否则会影响效率</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= test_time; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="built_in">rand</span>() % (n - <span class="number">2</span>) + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">quickPow</span>(a, n - <span class="number">1</span>, n) != <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很遗憾，费马小定理的逆定理并不成立，换言之，满足了 $a^{n - 1} \ \equiv \ 1 \ (mod \ n)$，a 也不一定是素数。</p>
<h5 id="卡迈克尔数"><a href="#卡迈克尔数" class="headerlink" title="卡迈克尔数"></a>卡迈克尔数</h5><p>上面的做法中随机地选择 a，很大程度地降低了犯错的概率。但是仍有一类数，上面的做法并不能准确地判断。</p>
<p>对于合数 n，如果对于所有正整数 a，a 和 n 互素，都有同余式 $a^{n - 1} \ \equiv \ 1 \ (mod \ n)$ 成立，则合数 n 为卡迈克尔数（Carmichael Number），又称为费马伪素数。</p>
<p>比如，561 &#x3D; 3 x 11 x 17 就是一个卡迈克尔数。</p>
<p>而且我们知道，若 n 为卡迈克尔数，则 m &#x3D; 2<sup>n</sup> - 1 也是一个卡迈克尔数，从而卡迈克尔数的个数是无穷的。</p>
<h5 id="二次探测定理"><a href="#二次探测定理" class="headerlink" title="二次探测定理"></a>二次探测定理</h5><p>如果 p 是奇素数，则 $x^{2} \ \equiv \ 1 \ (mod \ p)$ 的解为 $x \ \equiv \ 1 \ (mod \ p)$  或者 $x \ \equiv \ p-1 \ (mod \ p)$ 。</p>
<p>要证明该定理，只需将上面的方程移项，再使用平方差公式，得到 $(x + 1)(x - 1) \ \equiv \ 0 \ (mod \ p)$，即可得出上面的结论。</p>
<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><p>根据卡迈克尔数的性质，可知其一定不是 p<sup>e</sup>。</p>
<p>不妨将费马小定理和二次探测定理结合起来使用：</p>
<p>将 $a^{n - 1} \ \equiv \ 1 \ (mod \ n)$ 中的指数 n - 1 分解为 $n \ - \ 1 \ &#x3D; \ u \ \times \ 2^{t}$，在每轮测试中对随机出来的 a 先求出 $a^{u} \ (mod \ n)$，之后对这个值执行最多 t 次平方操作，若发现非平凡平方根时即可判断出其不是素数，否则通过此轮测试。</p>
<h5 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">millerRabbin</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">3</span>) <span class="keyword">return</span> n == <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> a = n - <span class="number">1</span>, b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!(a % <span class="number">2</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        a /= <span class="number">2</span>;</span><br><span class="line">        ++b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// test_time 为测试次数,建议设为不小于 8 的整数以保证正确率,但也不宜过大,否则会影响效率</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j; i &lt;= test_time; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">rand</span>() % (n - <span class="number">2</span>) + <span class="number">2</span>, v = <span class="built_in">quickPow</span>(x, a, n);</span><br><span class="line">        <span class="keyword">if</span> (v == <span class="number">1</span> || v == n - <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; b; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            v = (<span class="type">long</span> <span class="type">long</span>)v * v % n;</span><br><span class="line">            <span class="keyword">if</span> (v == n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j &gt;= b) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="最大公约数-·-GCD"><a href="#最大公约数-·-GCD" class="headerlink" title="最大公约数 · GCD"></a>最大公约数 · GCD</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>最大公约数即为 Greatest Common Divisor，常缩写为 gcd。</p>
<p>在素数一节中，我们已经介绍了约数的概念。</p>
<p>一组数的公约数，是指同时是这组数中每一个数的约数的数。而最大公约数，则是指所有公约数里面最大的一个。</p>
<h3 id="求法"><a href="#求法" class="headerlink" title="求法"></a>求法</h3><h4 id="欧几里得算法-·-O-log-n"><a href="#欧几里得算法-·-O-log-n" class="headerlink" title="欧几里得算法 · $O(\log n)$"></a>欧几里得算法 · $O(\log n)$</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!b) <span class="keyword">return</span> a;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="多个数的最大公约数"><a href="#多个数的最大公约数" class="headerlink" title="多个数的最大公约数"></a>多个数的最大公约数</h3><p>答案一定是每个数的约数，那么也一定是每相邻两个数的约数。我们采用归纳法，可以证明，每次取出两个数求出答案后再放回去，不会对所需要的答案造成影响。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">multi_gcd</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> tmp1, tmp2;</span><br><span class="line">    tmp1 = a[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp2 = a[i];</span><br><span class="line">        a[i] = <span class="built_in">gcd</span>(tmp1, tmp2);</span><br><span class="line">        tmp1 = a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="最小公倍数-·-LCM"><a href="#最小公倍数-·-LCM" class="headerlink" title="最小公倍数 · LCM"></a>最小公倍数 · LCM</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lcm</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a / <span class="built_in">gcd</span>(a, b) * b;	<span class="comment">// 先除再乘避免溢出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="多个数的最小公倍数"><a href="#多个数的最小公倍数" class="headerlink" title="多个数的最小公倍数"></a>多个数的最小公倍数</h3><p>可以发现，当我们求出两个数的 gcd 时，求最小公倍数是 $O(1)$ 的复杂度。那么对于多个数，我们其实没有必要求一个共同的最大公约数再去处理，最直接的方法就是，当我们算出两个数的 gcd，或许在求多个数的 gcd 时候，我们将它放入序列对后面的数继续求解，那么，我们转换一下，直接将最小公倍数放入序列即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">multi_lcm</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> tmp1, tmp2;</span><br><span class="line">    tmp1 = a[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp2 = a[i];</span><br><span class="line">        a[i] = <span class="built_in">lcm</span>(tmp1, tmp2);</span><br><span class="line">        tmp1 = a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>欧拉函数（Euler’s totient function），即 $\phi(n)$，表示的是小于等于 n 和 n 互质的数的个数。</p>
<p>比如说 $\phi(1) &#x3D; 1$。</p>
<p>当 n 是质数的时候，显然有 $\phi(n) &#x3D; n - 1$。</p>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ul>
<li><p>欧拉函数是积性函数。</p>
<p>积性是什么意思呢？如果有 $gcd(a, \ b) \ &#x3D; \ 1$，那么 $\phi(a \times b) &#x3D; \phi(a) \times \phi(b)$。</p>
<p>特别地，当 n 是奇数时 $\phi(2n) &#x3D; \phi(n)$。</p>
</li>
<li><p>$n &#x3D; \sum_{d|n} \phi(d)$</p>
</li>
<li><p>若 n &#x3D; p<sup>k</sup>，其中 p 是质数，那么 $\phi(n) &#x3D; p^{k} - p^{k-1}$。 </p>
</li>
<li><p>由唯一分解定理，设 $n &#x3D; \Pi_{i&#x3D;1}^{n}p_{i}^{k_{i}}$，其中 $p_{i}$是质数，有 $\phi(n) &#x3D; n \times \Pi_{i&#x3D;1}^{s} \frac{p_{i} - 1}{p_{i}}$。</p>
</li>
</ul>
<h3 id="求欧拉函数值"><a href="#求欧拉函数值" class="headerlink" title="求欧拉函数值"></a>求欧拉函数值</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">euler_phi</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m = <span class="built_in">int</span>(<span class="built_in">sqrt</span>(n + <span class="number">0.5</span>));</span><br><span class="line">    <span class="type">int</span> ans = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = ans / i * (i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (n % i == <span class="number">0</span>) n /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>) ans = ans / n * (n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果将上面的程序改成如下形式，会提升一点效率：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">euler_phi</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i * i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = ans / i * (i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (n % i == <span class="number">0</span>) n /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>) ans = ans / n * (n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h3><p>若 $gcd(a, \ m) \ &#x3D; \ 1$ 则 $a^{\phi(m)} \equiv 1 (mod m)$</p>
<h3 id="扩展欧拉定理"><a href="#扩展欧拉定理" class="headerlink" title="扩展欧拉定理"></a>扩展欧拉定理</h3><p>$$<br>a^{b} \equiv \left{<br>\begin{aligned}<br>a^{b \ mod \ \phi(p)} &amp; , &amp; gcd(a, \ p) \ &#x3D; \ 1 \<br>a^{b} &amp; , &amp; gcd(a, \ p) \ \neq \ 1 &amp; , \ b \ &lt; \ \phi(p) \ (mod \ p)\<br>a^{b \ mod \ \phi(p)+\phi(p)} &amp; , &amp; gcd(a, \ b) \ \neq \ 1 &amp; , \ b \ \geq \ \phi(p)<br>\end{aligned}<br>\right.<br>$$</p>
<h2 id="筛法"><a href="#筛法" class="headerlink" title="筛法"></a>筛法</h2><h3 id="素数筛法"><a href="#素数筛法" class="headerlink" title="素数筛法"></a>素数筛法</h3><p>如果我们想要知道小于等于 n 有多少个素数呢？</p>
<p>一个自然的想法是对于小于等于 n 的每个数进行一次质数检验。这种暴力的做法显然不能达到最优复杂度。</p>
<h4 id="埃拉托斯特尼（Eratosthenes）筛法-·-O-n-log-log-n"><a href="#埃拉托斯特尼（Eratosthenes）筛法-·-O-n-log-log-n" class="headerlink" title="埃拉托斯特尼（Eratosthenes）筛法 · $O(n\log\log n)$"></a>埃拉托斯特尼（Eratosthenes）筛法 · $O(n\log\log n)$</h4><p>如果 x 是合数，那么 x 的倍数也一定是合数。利用这个结论，我们可以避免很多次不必要的检测。</p>
<p>如果我们从小到大考虑每个数，然后同时把当前这个数的所有（比自己大的）倍数记为合数，那么运行结束的时候没有被标记的数就是素数了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Eratosthenes</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) is_prime[i] = <span class="number">1</span>;</span><br><span class="line">    is_prime[<span class="number">0</span>] = is_prime[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (is_prime[i])</span><br><span class="line">        &#123;</span><br><span class="line">            prime[p++] = i;  <span class="comment">// prime[p]是i,后置自增运算代表当前素数数量</span></span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">long</span> <span class="type">long</span>)i * i &lt;= n)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = i * i; j &lt;= n; j += i)</span><br><span class="line">                    <span class="comment">// 因为从 2 到 i - 1 的倍数我们之前筛过了，这里直接从 i</span></span><br><span class="line">                    <span class="comment">// 的倍数开始，提高了运行速度</span></span><br><span class="line">                    is_prime[j] = <span class="number">0</span>;  <span class="comment">// 是i的倍数的均不是素数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="筛至平方根-只筛奇数"><a href="#筛至平方根-只筛奇数" class="headerlink" title="筛至平方根 &amp;&amp; 只筛奇数"></a>筛至平方根 &amp;&amp; 只筛奇数</h5><p>显然，要找到直到 n 为止的所有素数，仅对不超过 $\sqrt{n}$ 的素数进行筛选就足够了。</p>
<p>因为除 2 以外的偶数都是合数，所以我们可以直接跳过它们，只用关心奇数就好。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function">vector&lt;<span class="type">char</span>&gt; <span class="title">is_prime</span><span class="params">(n + <span class="number">1</span>, <span class="literal">true</span>)</span></span>;</span><br><span class="line">is_prime[<span class="number">0</span>] = is_prime[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i * i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(i % <span class="number">2</span>)) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (is_prime[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i * i; j &lt;= n; j += i) is_prime[j] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="线性筛法"><a href="#线性筛法" class="headerlink" title="线性筛法"></a>线性筛法</h4><p>埃氏筛法仍有优化空间，它会将一个合数重复多次标记。有没有什么办法省掉无意义的步骤呢？答案是肯定的。</p>
<p>如果能让每个合数都只被标记一次，那么时间复杂度就可以降到 $O(n)$ 了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; MAXN; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i])</span><br><span class="line">        &#123;</span><br><span class="line">            phi[i] = i - <span class="number">1</span>;</span><br><span class="line">            pri[cnt++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; cnt; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1ll</span> * i * pri[j] &gt;= MAXN) <span class="keyword">break</span>;</span><br><span class="line">            vis[i * pri[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % pri[j])</span><br><span class="line">            &#123;</span><br><span class="line">                phi[i * pri[j]] = phi[i] * (pri[j] - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// i % pri[j] == 0</span></span><br><span class="line">                <span class="comment">// 换言之，i 之前被 pri[j] 筛过了</span></span><br><span class="line">                <span class="comment">// 由于 pri 里面质数是从小到大的，所以 i 乘上其他的质数的结果一定也是</span></span><br><span class="line">                <span class="comment">// pri[j] 的倍数 它们都被筛过了，就不需要再筛了，所以这里直接 break</span></span><br><span class="line">                <span class="comment">// 掉就好了</span></span><br><span class="line">                phi[i * pri[j]] = phi[i] * pri[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>pri[i]: 第 i 个素数</li>
<li>phi[i]: 1 ~ i 中与 i 互质的数的个数</li>
</ul>
<h3 id="筛法求欧拉函数"><a href="#筛法求欧拉函数" class="headerlink" title="筛法求欧拉函数"></a>筛法求欧拉函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">phi_table</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>* phi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) phi[i] = <span class="number">0</span>;</span><br><span class="line">    phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span> (!phi[i])</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= n; j += i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!phi[j]) phi[j] = j;</span><br><span class="line">                phi[j] = phi[j] / i * (i - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="筛法求约数个数"><a href="#筛法求约数个数" class="headerlink" title="筛法求约数个数"></a>筛法求约数个数</h3><p>d[i]: i 的约数个数</p>
<p>num[i]: i 的最小质因子出现次数</p>
<p>定理：若 $n \ &#x3D; \ \prod_{i&#x3D;1}^{m} p_{i}^{c_{i}}$ 则 $d_{i} \ &#x3D; \ \prod_{i&#x3D;1}^{m}c_{i} \ + \ 1$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pre</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    d[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!v[i]) v[i] = <span class="number">1</span>, p[++tot] = i, d[i] = <span class="number">2</span>, num[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; i &lt;= n / p[j]; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            v[p[j] * i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % p[j] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                num[i * p[j]] = num[i] + <span class="number">1</span>;</span><br><span class="line">                d[i * p[j]] = d[i] / num[i * p[j]] * (num[i * p[j]] + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                num[i * p[j]] = <span class="number">1</span>;</span><br><span class="line">                d[i * p[j]] = d[i] * <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="筛法求约数和"><a href="#筛法求约数和" class="headerlink" title="筛法求约数和"></a>筛法求约数和</h3><p>f[i]: i 的约数和</p>
<p>g[i]: i 的最小质因子的 $p \ + \ p^{1} \ + \ p^{2} \ + \ \cdots \ + \ p^{k}$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pre</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    g[<span class="number">1</span>] = f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!v[i]) v[i] = <span class="number">1</span>, p[++tot] = i, g[i] = i + <span class="number">1</span>, f[i] = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; i &lt;= n / p[j]; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            v[p[j] * i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % p[j] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                g[i * p[j]] = g[i] * p[j] + <span class="number">1</span>;</span><br><span class="line">                f[i * p[j]] = f[i] / g[i] * g[i * p[j]];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                f[i * p[j]] = f[i] * f[p[j]];</span><br><span class="line">                g[i * p[j]] = <span class="number">1</span> + p[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) f[i] = (f[i - <span class="number">1</span>] + f[i]) % Mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="乘法逆元"><a href="#乘法逆元" class="headerlink" title="乘法逆元"></a>乘法逆元</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p>如果一个线性同余方程 $ax \ \equiv \ 1 \ (mod \ b)$ ，则 x 称为 a mod b 的逆元，记作 $a^{-1}$。</p>
<h3 id="如何求逆元"><a href="#如何求逆元" class="headerlink" title="如何求逆元"></a>如何求逆元</h3><h4 id="扩展欧几里得法"><a href="#扩展欧几里得法" class="headerlink" title="扩展欧几里得法"></a>扩展欧几里得法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span>&amp; x, <span class="type">int</span>&amp; y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exgcd</span>(b, a % b, y, x);</span><br><span class="line">    y -= a / b * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="快速幂法"><a href="#快速幂法" class="headerlink" title="快速幂法"></a>快速幂法</h4><p>因为 $ax \ \equiv \ 1 \ (mod \ b)$；</p>
<p>所以 $ax \ \equiv \ a^{b-1} \ (mod \ b)$（根据费马小定理）；</p>
<p>所以 $x \ \equiv \ a^{b-2} \ (mod \ b)$。</p>
<p>然后我们就可以用快速幂来求了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    a = (a % p + p) % p;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ans = (a * ans) % p;</span><br><span class="line">        a = (a * a) % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用费马小定理需要限制 b 是一个素数，而扩展欧几里得算法只要求 $\gcd(a, \ p) \ &#x3D; \ 1$。</li>
</ul>
<h4 id="线性求逆元"><a href="#线性求逆元" class="headerlink" title="线性求逆元"></a>线性求逆元</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">	inv[i] = (<span class="type">long</span> <span class="type">long</span>)(p - p / i) * inv[p % i] % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="线性求任意-n-个数的逆元"><a href="#线性求任意-n-个数的逆元" class="headerlink" title="线性求任意 n 个数的逆元"></a>线性求任意 n 个数的逆元</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) s[i] = s[i - <span class="number">1</span>] * a[i] % p;</span><br><span class="line">sv[n] = <span class="built_in">qpow</span>(s[n], p - <span class="number">2</span>);</span><br><span class="line"><span class="comment">// 当然这里也可以用 exgcd 来求逆元,视个人喜好而定.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; --i) sv[i - <span class="number">1</span>] = sv[i] * a[i] % p;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) inv[i] = sv[i] * s[i - <span class="number">1</span>] % p;</span><br></pre></td></tr></table></figure>







<h2 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h2><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h3><p>中国剩余定理 (Chinese Remainder Theorem, CRT) 可求解如下形式的一元线性同余方程组（其中 $n_{1}, \ n_{2}, \ \cdots, \ n_{k}$ 两两互质）：<br>$$<br>\left {<br>\begin{array}{c}<br>x \ &amp;\equiv \ &amp;a_{1} \ (mod \ n_{1}) \<br>x \ &amp;\equiv \ &amp;a_{2} \ (mod \ n_{2}) \<br>&amp;\cdots\ \<br>x \ &amp;\equiv \ &amp;a_{k} \ (mod \ n_{k})<br>\end{array}<br>\right .<br>$$</p>
<h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><ol>
<li>计算所有模数的积 n；</li>
<li>对于第 i 个方程：<ol>
<li>计算 $m_{i} \ &#x3D; \ \frac{n}{n_{i}}$；</li>
<li>计算 $m_{i}$ 在模 $n_{i}$ 意义下的逆元 $m_{i}^{-1}$</li>
<li>计算 $c_{i} \ &#x3D; \ m_{i}m_{i}^{-1}$（<strong>不要对 $n_{i}$ 取模</strong>）。</li>
</ol>
</li>
<li>方程组的唯一解为：$a \ &#x3D; \ \sum_{i&#x3D;1}^{k}a_{i}c_{i} \ (mod \ n)$。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/02/03/2021-2-3-shu-lun/" data-id="clz6fe7hs00150loxb4g8aohf" data-title="2021.2.3" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E8%AE%BA/" rel="tag">数论</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-2021-2-2-背包" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/02/02/2021-2-2-bei-bao/" class="article-date">
  <time class="dt-published" datetime="2021-02-02T12:00:00.000Z" itemprop="datePublished">2021-02-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/ACM/">ACM</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/02/02/2021-2-2-bei-bao/">背包</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="背包"><a href="#背包" class="headerlink" title="背包"></a>背包</h1><h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote>
<p>背包问题 (Knapsack problem) 是一种组合优化的 NP 完全问题。问题可以描述为：给定一组物品，每种物品都有自己的重量和价格，在限定的总重量内，我们如何选择，才能使得物品的总价格最高。</p>
<p>——百度百科</p>
</blockquote>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul>
<li>01 背包：有 N 件物品和一个容量为 V 的背包。第 i 件物品的重量是 w[i]，价值是 v[i]。求解将哪些物品装入背包可使这些物品的重量总和不超过背包容量，且价值总和最大。<strong>每样物品可取1件</strong></li>
<li>完全背包：有 N 种物品和一个容量为 V 的背包，每种物品都有 <strong>无限</strong> 件可用。第 i 种物品的体积是 c，价值是 w。将哪些物品装入背包可使这些物品的体积总和不超过背包容量，且价值总和最大。</li>
<li>多重背包：有 N 种物品和一个容量为 V 的背包。第 i 种物品最多 <strong>有 n 件</strong> 可用，每件体积是 c，价值是 w。求解将哪些物品装入背包可使这些物品的体积总和不超过背包容量，且价值总和最大。</li>
</ul>
<h2 id="01-背包"><a href="#01-背包" class="headerlink" title="01 背包"></a>01 背包</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>有 N 件物品和一个容量为 V 的背包。第 i 件物品的重量是 w[i]，价值是 v[i]。求解将哪些物品装入背包可使这些物品的重量总和不超过背包容量，且价值总和最大。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>每样物品最多可以取1次，即对于每样物品只有 <strong>取</strong> 或 <strong>不取</strong> 两种状态。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/02/02/2021-2-2-bei-bao/" data-id="clz6fe7hr000s0lox7jun5ui0" data-title="背包" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/01%E8%83%8C%E5%8C%85/" rel="tag">01背包</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DP/" rel="tag">DP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/" rel="tag">多重背包</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/" rel="tag">完全背包</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-2021-1-31-最小生成树" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/31/2021-1-31-zui-xiao-sheng-cheng-shu/" class="article-date">
  <time class="dt-published" datetime="2021-01-31T06:20:31.000Z" itemprop="datePublished">2021-01-31</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/ACM/">ACM</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/31/2021-1-31-zui-xiao-sheng-cheng-shu/">最小生成树</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>一个有 n 个结点的连通图的生成树是原图的极小连通子图，且包含原图中的所有 n 个结点，并且有保持图连通的最少的边。</p>
<p>——百度百科</p>
</blockquote>
<h2 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>用贪心的思想，把所有的边从短到长排序，从最短的边开始判断，如果连接的两个点不是已经联通的，那就把这条边连起来。如果已经联通，则忽略这条边。</p>
<p>用并查集维护所有的点，联通的点在同一集合，从而判断点是否联通。</p>
<h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRTSECURE_NOWARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:4996)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 110</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, f[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EDGE</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> u, v, w;</span><br><span class="line">&#125; E[MAXN * MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(EDGE x, EDGE y)</span>	<span class="comment">//边从小到大排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x.w &lt; y.w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">int</span> x)</span>	<span class="comment">//并查集初始化</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= x; i++) f[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x == f[x] ? x : f[x] = <span class="built_in">Find</span>(f[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Kruskal</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> res = <span class="number">0</span>;	<span class="comment">// 存放结果</span></span><br><span class="line">	<span class="type">int</span> num = <span class="number">0</span>;	<span class="comment">// 记录当前选择了多少条边</span></span><br><span class="line">	<span class="built_in">Init</span>(m);</span><br><span class="line">	<span class="built_in">sort</span>(E + <span class="number">1</span>, E + <span class="number">1</span> + m, cmp);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> f1 = <span class="built_in">Find</span>(E[i].u);	<span class="comment">//  查询u顶点在哪个集合中</span></span><br><span class="line">		<span class="type">int</span> f2 = <span class="built_in">Find</span>(E[i].v);	<span class="comment">//  查询v顶点在哪个集合中</span></span><br><span class="line">		<span class="keyword">if</span> (f1 != f2)	<span class="comment">//  如果不在同一个集合中</span></span><br><span class="line">		&#123;</span><br><span class="line">			num++;	<span class="comment">//  选中的边数 +1</span></span><br><span class="line">			res += E[i].w;	<span class="comment">//  答案加上这条边的权值</span></span><br><span class="line">			f[f1] = f2;	<span class="comment">//  将这两个点合并到一个集合中</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (num == n - <span class="number">1</span>)	<span class="comment">// 如果已经找到了 n - 1条边，说明最小生成树已经构建完成了</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (num == n - <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">	<span class="keyword">else</span>  <span class="built_in">puts</span>(<span class="string">&quot;Impossible\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m) != EOF)	<span class="comment">//n 个点，m 条边</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!m) <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;E[i].u, &amp;E[i].v, &amp;E[i].w);</span><br><span class="line">		<span class="built_in">Kruskal</span>(n, m);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="复杂度-·-O-m-log-m"><a href="#复杂度-·-O-m-log-m" class="headerlink" title="复杂度 · $O(m \ log m)$"></a>复杂度 · $O(m \ log m)$</h3><h2 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol>
<li>选用图中的任意一个顶点$V_{0}$，从 $v_{0}$ 开始生成最小生成树</li>
<li>初始化 $d[v_{0}] \ &#x3D; \ 0$，其他的点的距离值 $d[i] \ &#x3D; \ INF$，其中 $d[i]$ 表示当前这棵小树到其他点的最小距离值</li>
<li>经过 N 次如下步骤操作，最后得到一个含 N 各顶点，N - 1 条边的最小生成树<ol>
<li>选择一个未标记的点 K，并且 $d[K]$ 的值是最小的</li>
<li>标记点 K 进入这棵小树</li>
<li>以 K 为中间点，更新这棵小树到未标记点的距离的最小值</li>
</ol>
</li>
<li>得到最小生成树 T</li>
</ol>
<h3 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRTSECURE_NOWARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:4996)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 110</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, mp[MAXN][MAXN], vis[MAXN], d[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Initmap</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(mp, INF, <span class="built_in">sizeof</span>(mp));</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= x; i++) mp[i][i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Prim</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">	<span class="type">int</span> index = <span class="number">1</span>;	<span class="comment">//当前加入到小树的顶点</span></span><br><span class="line">	<span class="type">int</span> res = <span class="number">0</span>;	<span class="comment">//存放结果</span></span><br><span class="line">	vis[index] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)	<span class="comment">//更新这个点到其他点的距离  </span></span><br><span class="line">		d[i] = mp[index][i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)	<span class="comment">//执行 n - 1 次，找剩下的n - 1 个点</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> minn = INF;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)	<span class="comment">//找出未加入小树且 d 最小的点</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (!vis[j] &amp;&amp; d[j] &lt; minn)</span><br><span class="line">			&#123;</span><br><span class="line">				minn = d[j];</span><br><span class="line">				index = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (minn == INF)	<span class="comment">//如果没有找到，说明不存在最小生成树</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;Impossible\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		res += minn;	<span class="comment">//累加答案</span></span><br><span class="line">		vis[index] = <span class="number">1</span>;	<span class="comment">//将这个点加入最小生成树中</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)	<span class="comment">//更新这个点加入后，当前这棵小树到未加入的点的最近距离</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (!vis[j] &amp;&amp; d[j] &gt; mp[index][j]) d[j] = mp[index][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m) != EOF)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!m) <span class="keyword">break</span>;</span><br><span class="line">		<span class="built_in">Initmap</span>(n);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, u, v, w; i &lt;= m; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">			mp[v][u] = <span class="built_in">min</span>(w, mp[u][v]);</span><br><span class="line">			mp[u][v] = <span class="built_in">min</span>(w, mp[u][v]);	<span class="comment">// 消除重边的影响</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">Prim</span>(n, m);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="复杂度-·-O-n-2"><a href="#复杂度-·-O-n-2" class="headerlink" title="复杂度 · $O(n^{2})$"></a>复杂度 · $O(n^{2})$</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/31/2021-1-31-zui-xiao-sheng-cheng-shu/" data-id="clz6fe7hp000i0lox4jo63ari" data-title="最小生成树" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Kruskal/" rel="tag">Kruskal</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Prim/" rel="tag">Prim</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/" rel="tag">最小生成树</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-2021-1-30-最短路" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/30/2021-1-30-zui-duan-lu/" class="article-date">
  <time class="dt-published" datetime="2021-01-30T11:26:09.000Z" itemprop="datePublished">2021-01-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/ACM/">ACM</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/30/2021-1-30-zui-duan-lu/">最短路</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>最短路问题是图论理论的一个经典问题。寻找最短路径就是在指定网络中两结点间找一条距离最小的路。最短路不仅仅指一般地理意义上的距离最短,还可以引申到其它的度量,如时间、费用、线路容量等。</p>
<p>——百度百科</p>
</blockquote>
<h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><ul>
<li><code>Chain · 链</code>：一个点和边的交错序列 $v_0 - e_1 - v_1 - e_2 - v_2 - \cdots - e_k - v_k$</li>
<li><code>Trail · 迹</code>：对于一条路径 $w$，若$e_1, e_2, \cdots, e_k$ 两两互不相同，则 $w$ 是一条迹</li>
<li><code>Path · 路径</code>：对于一条迹 $w$，除了 $v_0$ 和 $v_k$ 允许相同外，其余点两两互不相同，则称 $w$ 是一条路径</li>
<li><code>Circuit · 回路</code>：对于一个迹 $w$，若 $v_0 &#x3D; v_k$，则称 $w$ 是一个回路</li>
<li><code>Cycle · 环</code>：对于一条路径 $w$，若 $v_0 &#x3D; v_k$，则称 $w$ 是一个环</li>
</ul>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul>
<li><p>单源最短路</p>
<p>包括确定起点的最短路径问题，确定终点的最短路径问题（与确定起点的问题相反，该问题是已知终结结点，求最短路径的问题。在无向图中该问题与确定起点的问题完全等同，在有向图中该问题等同于把所有路径方向反转的确定起点的问题。） 。</p>
</li>
<li><p>多源最短路</p>
</li>
</ul>
<h2 id="链式前向星"><a href="#链式前向星" class="headerlink" title="链式前向星"></a>链式前向星</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRTSECURE_NOWARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:4996)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;	<span class="comment">//n 个点，m 条单向边</span></span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="type">int</span> front[<span class="number">10001</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EDGE</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> to, next, w;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">EDGE edge[<span class="number">10001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(front, <span class="number">0</span>, <span class="built_in">sizeof</span>(front));</span><br><span class="line">	cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	++cnt;</span><br><span class="line">	edge[cnt].to = v;</span><br><span class="line">	edge[cnt].w = w;</span><br><span class="line">	edge[cnt].next = front[u];</span><br><span class="line">	front[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">	<span class="built_in">Init</span>();</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> u, v, w;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">		<span class="built_in">add_edge</span>(u, v, w);</span><br><span class="line">		<span class="built_in">add_edge</span>(v, u, w);	<span class="comment">//双向边</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历与每个点相连的所有边</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = front[i]; j; j = edge[j].next)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, i, edge[j].to, edge[j].w);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Dijkstra-·-单源最短路"><a href="#Dijkstra-·-单源最短路" class="headerlink" title="Dijkstra · 单源最短路"></a>Dijkstra · 单源最短路</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol>
<li>将所有节点分成两个集合，已求出最短路的集合（集合1）和未求出最短路的集合（集合2）。</li>
<li>更新并记录集合2 中所有节点和源点的距离</li>
<li>从集合2 中找到距离源点距离最近的点</li>
<li>将该点移到集合1 中</li>
<li>重复步骤 2-3，直到集合2 为空</li>
</ol>
<p>这个方法用了贪心的思想，每次把距离最小的点视作确定的，因为它已经是未确定的点中距离源点最近的了，不可能存在一条路经过其他未确定的点到这个点，距离还比直接到这个点近的了。</p>
<ul>
<li><strong>不能有负权边</strong></li>
</ul>
<h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><ul>
<li><code>dis[]</code>：每个点到源点的距离</li>
<li><code>vis[]</code>：每个点属于的集合，0 - 未确定，1 - 已确定</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRTSECURE_NOWARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:4996)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;	<span class="comment">//n 个点，m 条边</span></span><br><span class="line"><span class="type">int</span> mp[<span class="number">10001</span>][<span class="number">10001</span>];</span><br><span class="line"><span class="type">int</span> dis[<span class="number">10001</span>], vis[<span class="number">10001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(mp, INF, <span class="built_in">sizeof</span>(mp));</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) mp[i][i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Getmap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> u, v, w;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> t = <span class="number">1</span>; t &lt;= m; t++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">		<span class="keyword">if</span> (w &lt; mp[u][v])</span><br><span class="line">		&#123;</span><br><span class="line">			mp[u][v] = w;</span><br><span class="line">			mp[v][u] = w;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> t = <span class="number">1</span>; t &lt;= n; t++) dis[t] = mp[x][t];</span><br><span class="line"></span><br><span class="line">	vis[x] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> t = <span class="number">1</span>; t &lt; n; t++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> minn = INF, temp;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (!vis[i] &amp;&amp; dis[i] &lt; minn)</span><br><span class="line">			&#123;</span><br><span class="line">				minn = dis[i];</span><br><span class="line">				temp = i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		vis[temp] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">			<span class="keyword">if</span> (mp[temp][i] + dis[temp] &lt; dis[i])</span><br><span class="line">				dis[i] = mp[temp][i] + dis[temp];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);	<span class="comment">//n 个点，m 条边</span></span><br><span class="line">	<span class="built_in">Init</span>();	<span class="comment">//地图初始化</span></span><br><span class="line">	<span class="built_in">Getmap</span>();	<span class="comment">//读图</span></span><br><span class="line">	<span class="built_in">Dijkstra</span>(x);	<span class="comment">//以点 x 为出发点的单源最短路</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d\t%d\n&quot;</span>, i, dis[i]);	<span class="comment">//dis[i]：x 点到 n 点的最短距离</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="复杂度-·-O-n2"><a href="#复杂度-·-O-n2" class="headerlink" title="复杂度 · $O(n2)$"></a>复杂度 · $O(n<sup>2</sup>)$</h3><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><ul>
<li><p>从一个点出发到所有点的距离：正 Dijkstra</p>
</li>
<li><p>从所有点出发到一个点的距离（<a target="_blank" rel="noopener" href="http://poj.org/problem?id=3268">POJ 3268 · Silver Cow Party</a>）</p>
<ul>
<li><p>把图反向</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> tmp = map[i][j];</span><br><span class="line">map[i][j] = map[j][i];</span><br><span class="line">map[j][i] = tmp;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Dijkstra</p>
</li>
</ul>
</li>
</ul>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><h2 id="Floyd-·-多源最短路"><a href="#Floyd-·-多源最短路" class="headerlink" title="Floyd · 多源最短路"></a>Floyd · 多源最短路</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>我们定义一个数组 <code>dis[k][x][y]</code> ，表示只允许经过结点 $V_1$ 到 $V_k$，结点 $x$ 到结点 $y$ 的最短路长度。很显然， <code>dis[n][x][y]</code> 就是最终结点 $x$ 到结点 $y$ 的最短路长度。</p>
<p><code>dis[0][x][y]</code> 是 $x$ 与 $y$ 的边权，或者 $0$，或者 $\infty$（当 $x$ 与 $y$ 间有直接相连的边的时候，为它们的边权；当 $x &#x3D; y$ 的时候为零，因为到本身的距离为零；当 $x$ 与 $y$ 没有直接相连的边的时候，为 $\infty$）</p>
<p><code>dis[k][x][y] = min(dis[k-1][x][y], dis[k-1][x][k]+dis[k-1][k][y])</code> （ <code>dis[k-1][x][y]</code> 为不经过 $k$ 点的最短路径，而 <code>dis[k-1][x][k]+dis[k-1][k][y]</code> 为经过了 $k$ 点的最短路）。</p>
<ul>
<li><p><strong>能有负权边</strong></p>
</li>
<li><p><strong>不能有负环</strong></p>
</li>
</ul>
<h3 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Floyd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                dis[k][i][j] = <span class="built_in">min</span>(dis[k - <span class="number">1</span>][i][j], dis[k - <span class="number">1</span>][i][k] + dis[k - <span class="number">1</span>][k][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不难看出，$k$ 每次循环后只是调用了 $k - 1$ 的数据，而 $k$ 之前的数据对结果没有作用，因此第一维是可以省略的（数据可以不保存，直接在下一次循环被覆盖，但是还是需要有这 $k$ 次循环）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRTSECURE_NOWARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:4996)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;	<span class="comment">//n 个点，m 条边</span></span><br><span class="line"><span class="type">int</span> dis[<span class="number">10001</span>][<span class="number">10001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, INF, <span class="built_in">sizeof</span>(dis));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) dis[i][i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Getmap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u, v, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        <span class="keyword">if</span> (w &lt; dis[u][v])</span><br><span class="line">        &#123;</span><br><span class="line">            dis[u][v] = w;</span><br><span class="line">            dis[v][u] = w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Floyd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                dis[i][j] = <span class="built_in">min</span>(dis[i][j], dis[i][k] + dis[k][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">Init</span>();</span><br><span class="line">    <span class="built_in">Getmap</span>();</span><br><span class="line">    <span class="built_in">Floyd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, i, j, dis[i][j]);  <span class="comment">//dis[i][j] = i 到 j 的最短距离</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><ul>
<li>时间复杂度：$O(n^3)$</li>
<li>空间复杂度：$O(n2)$</li>
</ul>
<h2 id="Bellman-Ford-·-单源最短路"><a href="#Bellman-Ford-·-单源最短路" class="headerlink" title="Bellman-Ford · 单源最短路"></a>Bellman-Ford · 单源最短路</h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ul>
<li><p>松弛</p>
<p>每次松弛操作实际上是对相邻节点的访问，第 $n$ 次松弛操作保证了所有深度为 $n$ 的路径最短。由于图的最短路径最长不会经过超过 $|V| - 1$ 条边，所以可知贝尔曼-福特算法所得为最短路径。</p>
</li>
<li><p>负边权操作</p>
<p>与 Dijkstra 算法不同的是，迪科斯彻算法的基本操作“拓展”是在深度上寻路，而“松弛”操作则是在广度上寻路，这就确定了贝尔曼-福特算法可以对负边进行操作而不会影响结果。</p>
</li>
<li><p>负权环判定</p>
<p>因为负权环可以无限制的降低总花费，所以如果发现第 $n$ 次操作仍可降低花销，就一定存在负权环。</p>
</li>
<li><p><strong>能有负权边</strong></p>
</li>
<li><p><strong>能有负环</strong></p>
</li>
</ul>
<h3 id="优化-1"><a href="#优化-1" class="headerlink" title="优化"></a>优化</h3><ul>
<li><p>循环的提前跳出</p>
<p>在实际操作中，贝尔曼-福特算法经常会在未达到 $|V| - 1$ 次前就出解，$|V| - 1$ 其实是最大值。于是可以在循环中设置判定，在某次循环不再进行松弛时，直接退出循环，进行负权环判定。</p>
</li>
<li><p>最短路径快速算法</p>
<p>松弛操作必定只会发生在最短路径前导节点松弛成功过的节点上，用一个队列记录松弛过的节点，可以避免了冗余计算。该算法的复杂度为 $O(k|E|)$，$k$ 是个比较小的系数，但该结论未得到广泛认可。</p>
</li>
</ul>
<h3 id="模板-2"><a href="#模板-2" class="headerlink" title="模板"></a>模板</h3><ul>
<li><del>SPFA已死</del></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRTSECURE_NOWARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:4996)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;	<span class="comment">//n 个点，m 条单向边</span></span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="type">int</span> dis[<span class="number">10001</span>];</span><br><span class="line"><span class="type">int</span> front[<span class="number">10001</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EDGE</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> to, next, w;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">EDGE edge[<span class="number">10001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(front, <span class="number">0</span>, <span class="built_in">sizeof</span>(front));</span><br><span class="line">	cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	++cnt;</span><br><span class="line">	edge[cnt].to = v;</span><br><span class="line">	edge[cnt].w = w;</span><br><span class="line">	edge[cnt].next = front[u];</span><br><span class="line">	front[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SPFA</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">	<span class="type">bool</span> vis[<span class="number">10001</span>];</span><br><span class="line">	<span class="type">int</span>  cnt[<span class="number">10001</span>];</span><br><span class="line">	<span class="built_in">memset</span>(dis, INF, <span class="built_in">sizeof</span>(dis));</span><br><span class="line">	<span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">	<span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="built_in">sizeof</span>(cnt));</span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) q.<span class="built_in">pop</span>();</span><br><span class="line">	dis[s] = <span class="number">0</span>;</span><br><span class="line">	cnt[s] = <span class="number">1</span>;</span><br><span class="line">	q.<span class="built_in">push</span>(s);</span><br><span class="line">	vis[s] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		vis[x] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = front[x]; i; i = edge[i].next)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> k = edge[i].to;</span><br><span class="line">			<span class="keyword">if</span> (dis[k] &gt; dis[x] + edge[i].w)</span><br><span class="line">			&#123;</span><br><span class="line">				dis[k] = dis[x] + edge[i].w;</span><br><span class="line">				cnt[k] = cnt[x] + <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span> (cnt[k] &gt; n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">if</span> (!vis[k])</span><br><span class="line">				&#123;</span><br><span class="line">					vis[k] = <span class="number">1</span>;</span><br><span class="line">					q.<span class="built_in">push</span>(k);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">	<span class="built_in">Init</span>();</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> u, v, w;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">		<span class="built_in">add_edge</span>(u, v, w);</span><br><span class="line">		<span class="built_in">add_edge</span>(v, u, w);	<span class="comment">//双向边</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//SPFA(x)：以 x 点为源点的单源最短路</span></span><br><span class="line">	<span class="comment">//dis[y]：x 到 y 的最短距离</span></span><br><span class="line">	<span class="comment">//SPFA 返回值：是否存在负环</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">SPFA</span>(i)) <span class="built_in">printf</span>(<span class="string">&quot;%d Yes\n&quot;</span>, i);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d No\n&quot;</span>, i);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, i, j, dis[j]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="复杂度-·-O-V-·-E"><a href="#复杂度-·-O-V-·-E" class="headerlink" title="复杂度 · $O(|V| · |E|)$"></a>复杂度 · $O(|V| · |E|)$</h3><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><h3 id="A-最短路-·-HDU-2544"><a href="#A-最短路-·-HDU-2544" class="headerlink" title="A  最短路 · HDU 2544"></a>A <a target="_blank" rel="noopener" href="https://vjudge.net/contest/420578#problem/A"> 最短路</a> · <a target="_blank" rel="noopener" href="http://acm.hdu.edu.cn/showproblem.php?pid=2544">HDU 2544</a></h3><h3 id="B-Til-the-Cows-Come-Home-·-POJ-2387"><a href="#B-Til-the-Cows-Come-Home-·-POJ-2387" class="headerlink" title="B  Til the Cows Come Home · POJ 2387"></a>B <a target="_blank" rel="noopener" href="https://vjudge.net/contest/420578#problem/B"> Til the Cows Come Home</a> · <a target="_blank" rel="noopener" href="http://poj.org/problem?id=2387">POJ 2387</a></h3><h3 id="C-Silver-Cow-Party-·-POJ-3268"><a href="#C-Silver-Cow-Party-·-POJ-3268" class="headerlink" title="C  Silver Cow Party · POJ 3268"></a>C <a target="_blank" rel="noopener" href="https://vjudge.net/contest/420578#problem/C"> Silver Cow Party</a> · <a target="_blank" rel="noopener" href="http://poj.org/problem?id=3268">POJ 3268</a></h3><h3 id="D-Heavy-Transportation-·-POJ-1797"><a href="#D-Heavy-Transportation-·-POJ-1797" class="headerlink" title="D  Heavy Transportation ·  POJ 1797"></a>D <a target="_blank" rel="noopener" href="https://vjudge.net/contest/420578#problem/D"> Heavy Transportation</a> · <a target="_blank" rel="noopener" href="http://poj.org/problem?id=1797"> POJ 1797</a></h3><h3 id="E-Cow-Contest-·-POJ-3660"><a href="#E-Cow-Contest-·-POJ-3660" class="headerlink" title="E  Cow Contest · POJ 3660"></a>E <a target="_blank" rel="noopener" href="https://vjudge.net/contest/420578#problem/E"> Cow Contest</a> · <a target="_blank" rel="noopener" href="http://poj.org/problem?id=3660">POJ 3660</a></h3><h3 id="F-Edge-Deletion-·-CodeForces-1076D"><a href="#F-Edge-Deletion-·-CodeForces-1076D" class="headerlink" title="F Edge Deletion · CodeForces 1076D"></a>F <a target="_blank" rel="noopener" href="https://vjudge.net/contest/420578#problem/F">Edge Deletion</a> · <a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/1076/D">CodeForces 1076D</a></h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/30/2021-1-30-zui-duan-lu/" data-id="clz6fe7hp000f0lox6lv4a887" data-title="最短路" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Dijkstra/" rel="tag">Dijkstra</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Floyd/" rel="tag">Floyd</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SPFA/" rel="tag">SPFA</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-2021-1-27-基础-DP" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/27/2021-1-27-ji-chu-dp/" class="article-date">
  <time class="dt-published" datetime="2021-01-27T12:00:00.000Z" itemprop="datePublished">2021-01-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/ACM/">ACM</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/27/2021-1-27-ji-chu-dp/">基础 DP</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="基础-DP"><a href="#基础-DP" class="headerlink" title="基础 DP"></a>基础 DP</h1><h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><p>斐波那契数列：1, 1, 2, 3, 5, 8, 13, 21, 34, 55, …</p>
<p>即：</p>
<ul>
<li>a<sub>n</sub> &#x3D; 1	(n &#x3D; 1 or n &#x3D; 2)</li>
<li>a<sub>n</sub> &#x3D; a<sub>n-1</sub> + a<sub>n-2</sub>	(n &gt;&#x3D; 3)</li>
</ul>
<p>求斐波那契的第 n 项</p>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>找到了其中的 <strong>最优子结构</strong>（递归公式）：f(n) &#x3D; f(n - 1) + f(n - 2)</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">func</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">func</span>(n - <span class="number">1</span>) + <span class="built_in">func</span>(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="复杂度-·-O-2n"><a href="#复杂度-·-O-2n" class="headerlink" title="复杂度 · O(2n)"></a>复杂度 · O(2<sup>n</sup>)</h3><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>计算 f(n) 时要计算 f(n - 1) 和 f(n - 2)，而计算 f(n - 1) 要计算 f(n - 2) 和 f(n - 3)…因此有很多是重复计算，因此考虑到用空间换时间，记录下这些值，以后需要计算这些值的时候直接返回已经计算得到的值即可</p>
<h2 id="空间换时间-·-记忆化"><a href="#空间换时间-·-记忆化" class="headerlink" title="空间换时间 · 记忆化"></a>空间换时间 · 记忆化</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>发现有很多值重复计算，用空间换时间</p>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> f[<span class="number">1001</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">func</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!f[n]) f[n] = <span class="built_in">func</span>(n - <span class="number">1</span>) + <span class="built_in">func</span>(n - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> f[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="复杂度-·-O-n"><a href="#复杂度-·-O-n" class="headerlink" title="复杂度 · O(n)"></a>复杂度 · O(n)</h3><h3 id="优化-1"><a href="#优化-1" class="headerlink" title="优化"></a>优化</h3><p>不难发现，结果是从前往后一位一位计算得到的，第 3 位，第 4 位…第 n 位。而每次计算的时候只与这一位的前两位有关系，因此可以使用循环的方法完成。</p>
<h2 id="递归变循环"><a href="#递归变循环" class="headerlink" title="递归变循环"></a>递归变循环</h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>打印空间，发现是按顺序从前往后运行的</p>
<h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> f[<span class="number">10001</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">func</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i++) f[i] = f[i - <span class="number">1</span>] + f[i - <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">return</span> f[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><ul>
<li><p>时间复杂度 · O(n)</p>
</li>
<li><p>空间复杂度 · O(n)</p>
</li>
</ul>
<h3 id="优化-2"><a href="#优化-2" class="headerlink" title="优化"></a>优化</h3><p>不难发现，当前值至于前两个值有关，因此不需要保留前两个之前的值</p>
<h2 id="空间压缩-·-即用即抛"><a href="#空间压缩-·-即用即抛" class="headerlink" title="空间压缩 · 即用即抛"></a>空间压缩 · 即用即抛</h2><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>发现很多空间被重复利用，每次计算只与前两项有关</p>
<h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> a = <span class="number">1</span>, b = <span class="number">1</span>, c;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">func</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        c = b;</span><br><span class="line">        b = a + b;</span><br><span class="line">        a = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><p>时间复杂度 · O(n)</p>
</li>
<li><p>空间复杂度 · O(1)</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/27/2021-1-27-ji-chu-dp/" data-id="clz6fe7ho000b0lox4bf7c40x" data-title="基础 DP" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DP/" rel="tag">DP</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-2021-1-25-线段树" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/25/2021-1-25-xian-duan-shu/" class="article-date">
  <time class="dt-published" datetime="2021-01-25T10:00:00.000Z" itemprop="datePublished">2021-01-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/ACM/">ACM</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/25/2021-1-25-xian-duan-shu/">线段树</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h1><h2 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h2><p>假设需要反复对一个数组 a[] 进行以下两个操作：</p>
<ul>
<li><p>Query · 求和</p>
<p>对 a[l] ~ a[r] 求和</p>
</li>
<li><p>Update · 修改</p>
<p>将 a[idx] 的值修改为 val</p>
</li>
</ul>
<p>则有如下解决办法：</p>
<h3 id="朴素做法"><a href="#朴素做法" class="headerlink" title="朴素做法"></a>朴素做法</h3><ul>
<li><p>Build</p>
<p><code>for (int i = 1; i &lt;= n; i++) scanf (&quot;%d&quot;, &amp;a[i]);</code></p>
</li>
<li><p>Query</p>
<p><code>for (int i = l; i &lt;= r; i++) sum += a[i];</code> <code>O(n)</code></p>
</li>
<li><p>Update</p>
<p><code>a[idx] = val;</code> <code>O(1)</code></p>
</li>
</ul>
<h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><ul>
<li><p>Build</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= l; i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">	sum_a[i] = sum_a[i<span class="number">-1</span>] + a[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Query</p>
<p><code>sum = sum_a[r] - sum_a[l - 1];</code> <code>O(1)</code></p>
</li>
<li><p>Update</p>
<p><code>for (int i = idx; i &lt;= n; i++) sum_a[i] += val; </code> <code>O(n)</code></p>
</li>
</ul>
<p>可见，两种方法的时间复杂度都较高，于是引入线段树的数据结构</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>线段树是一种二叉搜索树，与区间树相似，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。</p>
<p>——百度百科</p>
</blockquote>
<ul>
<li><p>Build</p>
<p>如图，区间依次对半分，每个节点存储一部分区间的和，节点按序标记为 1 ~ n（图中为 0 ~ n - 1）</p>
<img src="https://cdn.jsdelivr.net/gh/OwlllOvO/Hexo-image/20210125202804.png" style="zoom: 50%;" />
</li>
<li><p>Query <code>O(logn)</code></p>
<ul>
<li>从根结点开始划分求和区间</li>
<li>如果节点区间为求和区间的子集：返回节点值</li>
<li>如果节点区间与求和区间无交集：返回 0</li>
</ul>
</li>
<li><p>Update <code>O(logn)</code></p>
<ul>
<li>找到修改的节点，修改值</li>
<li>向上更新节点值</li>
</ul>
</li>
</ul>
<h2 id="模板-·-单点修改-·-数组"><a href="#模板-·-单点修改-·-数组" class="headerlink" title="模板 · 单点修改 · 数组"></a>模板 · 单点修改 · 数组</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 输入数据个数 n</span></span><br><span class="line"><span class="comment"> 一行输入 n 个数据</span></span><br><span class="line"><span class="comment"> 输入修改个数 m</span></span><br><span class="line"><span class="comment"> m 行每行修改下标 idx 及修改数据 val</span></span><br><span class="line"><span class="comment"> 输入查询个数 q</span></span><br><span class="line"><span class="comment"> q 行每行查询左边界右边界 l r</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRTSECURE_NOWARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:4996)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_LEN = <span class="number">1000016</span>;</span><br><span class="line"><span class="type">int</span> n, m, q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SEGT</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> arr[MAX_LEN], tree[MAX_LEN &lt;&lt; <span class="number">2</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build_tree</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> start, <span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == end)</span><br><span class="line">        &#123;</span><br><span class="line">            tree[node] = arr[start];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> mid = (start + end) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> left_node  = node &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> right_node = node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">build_tree</span>(left_node,  start,   mid);</span><br><span class="line">        <span class="built_in">build_tree</span>(right_node, mid + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">        tree[node] = tree[left_node] + tree[right_node];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update_tree</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> idx, <span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == end)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[idx] = val;</span><br><span class="line">            tree[node] = arr[idx];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> mid = (start + end) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> left_node  = node &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> right_node = node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (idx &lt;= mid)</span><br><span class="line">            <span class="built_in">update_tree</span>(left_node,  start,   mid, idx, val);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">update_tree</span>(right_node, mid + <span class="number">1</span>, end, idx, val);</span><br><span class="line"></span><br><span class="line">        tree[node] = tree[left_node] + tree[right_node];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query_tree</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r &lt; start || l &gt; end) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= start &amp;&amp; r &gt;= end) <span class="keyword">return</span> tree[node];</span><br><span class="line">        <span class="keyword">if</span> (start == end) <span class="keyword">return</span> tree[node];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> mid = (start + end) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> left_node  = node &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> right_node = node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> sum_left  = <span class="built_in">query_tree</span>(left_node,  start,   mid, l, r);</span><br><span class="line">        <span class="type">int</span> sum_right = <span class="built_in">query_tree</span>(right_node, mid + <span class="number">1</span>, end, l, r);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum_left + sum_right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SEGT segt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;segt.arr[i]);</span><br><span class="line">        segt.<span class="built_in">build_tree</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">        <span class="keyword">while</span> (m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> idx, val;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;idx, &amp;val);</span><br><span class="line">            segt.<span class="built_in">update_tree</span>(<span class="number">1</span>, <span class="number">1</span>, n, idx, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q);</span><br><span class="line">        <span class="keyword">while</span> (q--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l, r;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, segt.<span class="built_in">query_tree</span>(<span class="number">1</span>, <span class="number">1</span>, n, l, r));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="模板-·-区间修改"><a href="#模板-·-区间修改" class="headerlink" title="模板 · 区间修改"></a>模板 · 区间修改</h2><h2 id="模板-·-权值线段树"><a href="#模板-·-权值线段树" class="headerlink" title="模板 · 权值线段树"></a>模板 · 权值线段树</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRTSECURE_NOWARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:4996)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, p;</span><br><span class="line"><span class="type">int</span> a[<span class="number">10001</span>];</span><br><span class="line"><span class="type">int</span> arr[<span class="number">10001</span>];	<span class="comment">//arr[x]表示数 x 有多少个</span></span><br><span class="line"><span class="type">int</span> tree[<span class="number">10001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build_tree</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span> (l == r)</span><br><span class="line">	&#123;</span><br><span class="line">		tree[node] = arr[l];</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> left_node = node * <span class="number">2</span>;</span><br><span class="line">	<span class="type">int</span> right_node = node * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">build_tree</span>(left_node, l, mid);</span><br><span class="line">	<span class="built_in">build_tree</span>(right_node, mid + <span class="number">1</span>, r);</span><br><span class="line">	tree[node] = tree[left_node] + tree[right_node];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update_tree</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k, <span class="type">int</span> cnt)</span>	<span class="comment">//表示数k的个数多cnt个</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span> (l == r)</span><br><span class="line">	&#123;</span><br><span class="line">		tree[node] += cnt;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> left_node = node * <span class="number">2</span>;</span><br><span class="line">	<span class="type">int</span> right_node = node * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (k &lt;= mid)</span><br><span class="line">		<span class="built_in">update_tree</span>(left_node, l, mid, k, cnt);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">update_tree</span>(right_node, mid + <span class="number">1</span>, r, k, cnt);</span><br><span class="line">	tree[node] = tree[left_node] + tree[right_node];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query_tree</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span>	<span class="comment">//查询数k有多少个</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span> (l == r)</span><br><span class="line">		<span class="keyword">return</span> tree[node];</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> left_node = node * <span class="number">2</span>;</span><br><span class="line">	<span class="type">int</span> right_node = node * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (k &lt;= mid)</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">query_tree</span>(left_node, l, mid, k);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">query_tree</span>(right_node, mid + <span class="number">1</span>, r, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kth_tree</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span>	<span class="comment">//查询第k大值是多少</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span> (l == r)</span><br><span class="line">		<span class="keyword">return</span> l;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> left_node = node * <span class="number">2</span>;</span><br><span class="line">	<span class="type">int</span> right_node = node * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> s1 = tree[left_node];</span><br><span class="line">	<span class="type">int</span> s2 = tree[right_node];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (k &lt;= s2)</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">kth_tree</span>(right_node, mid + <span class="number">1</span>, r, k);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">kth_tree</span>(left_node, l, mid, k - s2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">		arr[a[i]]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;m, &amp;p);</span><br><span class="line">	<span class="built_in">build_tree</span>(<span class="number">1</span>, <span class="number">1</span>, m);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="built_in">kth_tree</span>(<span class="number">1</span>, <span class="number">1</span>, m, p));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><h3 id="A-例题1-·-SPOJ-GSS1"><a href="#A-例题1-·-SPOJ-GSS1" class="headerlink" title="A 例题1 · SPOJ GSS1"></a>A <a target="_blank" rel="noopener" href="https://vjudge.net/contest/419506#problem/A">例题1</a> · <a target="_blank" rel="noopener" href="https://vjudge.net/problem/SPOJ-GSS1/origin">SPOJ GSS1</a></h3><h3 id="B-例题2-·-Gym-102770B"><a href="#B-例题2-·-Gym-102770B" class="headerlink" title="B 例题2 · Gym 102770B"></a>B <a target="_blank" rel="noopener" href="https://vjudge.net/contest/419506#problem/B">例题2</a> · <a target="_blank" rel="noopener" href="https://vjudge.net/problem/Gym-102770B/origin">Gym 102770B</a></h3><h3 id="C-例题3-·-POJ-2182"><a href="#C-例题3-·-POJ-2182" class="headerlink" title="C 例题3 · POJ 2182"></a>C <a target="_blank" rel="noopener" href="https://vjudge.net/contest/419506#problem/C">例题3</a> · <a target="_blank" rel="noopener" href="https://vjudge.net/problem/POJ-2182/origin">POJ 2182</a></h3><h3 id="D-【模板】单点修改-·-HDU-1166"><a href="#D-【模板】单点修改-·-HDU-1166" class="headerlink" title="D 【模板】单点修改 · HDU 1166"></a>D <a target="_blank" rel="noopener" href="https://vjudge.net/contest/419506#problem/D">【模板】单点修改</a> · <a target="_blank" rel="noopener" href="https://vjudge.net/problem/HDU-1166/origin">HDU 1166</a></h3><h3 id="E-【模板】区间修改-·-POJ-3468"><a href="#E-【模板】区间修改-·-POJ-3468" class="headerlink" title="E 【模板】区间修改 · POJ 3468"></a>E <a target="_blank" rel="noopener" href="https://vjudge.net/contest/419506#problem/E">【模板】区间修改</a> · <a target="_blank" rel="noopener" href="https://vjudge.net/problem/POJ-3468/origin">POJ 3468</a></h3><h3 id="F-练习题1-·-CodeForces-339D"><a href="#F-练习题1-·-CodeForces-339D" class="headerlink" title="F 练习题1 · CodeForces 339D"></a>F <a target="_blank" rel="noopener" href="https://vjudge.net/contest/419506#problem/F">练习题1</a> · <a target="_blank" rel="noopener" href="https://vjudge.net/problem/CodeForces-339D/origin">CodeForces 339D</a></h3><h3 id="G-练习题2-·-HDU-2795"><a href="#G-练习题2-·-HDU-2795" class="headerlink" title="G 练习题2 · HDU 2795"></a>G <a target="_blank" rel="noopener" href="https://vjudge.net/contest/419506#problem/G">练习题2</a> · <a target="_blank" rel="noopener" href="https://vjudge.net/problem/HDU-2795/origin">HDU 2795</a></h3><h3 id="H-练习题3-·-HDU-2852"><a href="#H-练习题3-·-HDU-2852" class="headerlink" title="H 练习题3 · HDU 2852"></a>H <a target="_blank" rel="noopener" href="https://vjudge.net/contest/419506#problem/H">练习题3</a> · <a target="_blank" rel="noopener" href="https://vjudge.net/problem/HDU-2852/origin">HDU 2852</a></h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/25/2021-1-25-xian-duan-shu/" data-id="clz6fe7hn000a0lox9ngq9148" data-title="线段树" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/" rel="tag">线段树</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/ACM/">ACM</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Coding/">Coding</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/HZNU/">HZNU</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Manual/">Manual</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tech/">Tech</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/01%E8%83%8C%E5%8C%85/" rel="tag">01背包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AC-%E8%87%AA%E5%8A%A8%E6%9C%BA/" rel="tag">AC 自动机</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Abstract-class/" rel="tag">Abstract class</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Account/" rel="tag">Account</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/App/" rel="tag">App</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BFS/" rel="tag">BFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DFS/" rel="tag">DFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DP/" rel="tag">DP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Dijkstra/" rel="tag">Dijkstra</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Eclipse/" rel="tag">Eclipse</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Email/" rel="tag">Email</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Floyd/" rel="tag">Floyd</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/" rel="tag">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/" rel="tag">Hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JAVA/" rel="tag">JAVA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/KMP/" rel="tag">KMP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kruskal/" rel="tag">Kruskal</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LCA/" rel="tag">LCA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mac/" rel="tag">Mac</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MathJax/" rel="tag">MathJax</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Media/" rel="tag">Media</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Prim/" rel="tag">Prim</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Regex/" rel="tag">Regex</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SPFA/" rel="tag">SPFA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/STL/" rel="tag">STL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Trie/" rel="tag">Trie</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/VPS/" rel="tag">VPS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vim/" rel="tag">Vim</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web/" rel="tag">Web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/aria2/" rel="tag">aria2</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/macOS/" rel="tag">macOS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/markdown/" rel="tag">markdown</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/qBittorrent/" rel="tag">qBittorrent</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%88%86/" rel="tag">二分</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/" rel="tag">二分图</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8C%BA%E9%97%B4DP/" rel="tag">区间DP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/" rel="tag">博弈论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9B%BE/" rel="tag">图</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/" rel="tag">多重背包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/" rel="tag">完全背包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/" rel="tag">并查集</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/" rel="tag">归并排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/" rel="tag">快速幂</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/" rel="tag">拓扑排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%90%9C%E7%B4%A2/" rel="tag">搜索</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E4%BD%8D-DP/" rel="tag">数位 DP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E8%AE%BA/" rel="tag">数论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/" rel="tag">最小生成树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A0%91/" rel="tag">树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/" rel="tag">线段树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/" rel="tag">计算几何</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%86%E5%BA%8F%E5%AF%B9/" rel="tag">逆序对</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/01%E8%83%8C%E5%8C%85/" style="font-size: 10px;">01背包</a> <a href="/tags/AC-%E8%87%AA%E5%8A%A8%E6%9C%BA/" style="font-size: 10px;">AC 自动机</a> <a href="/tags/Abstract-class/" style="font-size: 10px;">Abstract class</a> <a href="/tags/Account/" style="font-size: 10px;">Account</a> <a href="/tags/App/" style="font-size: 13.33px;">App</a> <a href="/tags/BFS/" style="font-size: 10px;">BFS</a> <a href="/tags/C/" style="font-size: 20px;">C++</a> <a href="/tags/DFS/" style="font-size: 10px;">DFS</a> <a href="/tags/DP/" style="font-size: 16.67px;">DP</a> <a href="/tags/Dijkstra/" style="font-size: 10px;">Dijkstra</a> <a href="/tags/Eclipse/" style="font-size: 10px;">Eclipse</a> <a href="/tags/Email/" style="font-size: 10px;">Email</a> <a href="/tags/Floyd/" style="font-size: 10px;">Floyd</a> <a href="/tags/Git/" style="font-size: 10px;">Git</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/JAVA/" style="font-size: 16.67px;">JAVA</a> <a href="/tags/KMP/" style="font-size: 10px;">KMP</a> <a href="/tags/Kruskal/" style="font-size: 10px;">Kruskal</a> <a href="/tags/LCA/" style="font-size: 10px;">LCA</a> <a href="/tags/Mac/" style="font-size: 10px;">Mac</a> <a href="/tags/MathJax/" style="font-size: 10px;">MathJax</a> <a href="/tags/Media/" style="font-size: 10px;">Media</a> <a href="/tags/Prim/" style="font-size: 10px;">Prim</a> <a href="/tags/Regex/" style="font-size: 10px;">Regex</a> <a href="/tags/SPFA/" style="font-size: 10px;">SPFA</a> <a href="/tags/STL/" style="font-size: 10px;">STL</a> <a href="/tags/Trie/" style="font-size: 10px;">Trie</a> <a href="/tags/VPS/" style="font-size: 10px;">VPS</a> <a href="/tags/Vim/" style="font-size: 10px;">Vim</a> <a href="/tags/Web/" style="font-size: 10px;">Web</a> <a href="/tags/aria2/" style="font-size: 10px;">aria2</a> <a href="/tags/macOS/" style="font-size: 10px;">macOS</a> <a href="/tags/markdown/" style="font-size: 10px;">markdown</a> <a href="/tags/qBittorrent/" style="font-size: 10px;">qBittorrent</a> <a href="/tags/%E4%BA%8C%E5%88%86/" style="font-size: 10px;">二分</a> <a href="/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/" style="font-size: 10px;">二分图</a> <a href="/tags/%E5%8C%BA%E9%97%B4DP/" style="font-size: 10px;">区间DP</a> <a href="/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/" style="font-size: 10px;">博弈论</a> <a href="/tags/%E5%9B%BE/" style="font-size: 10px;">图</a> <a href="/tags/%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/" style="font-size: 10px;">多重背包</a> <a href="/tags/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/" style="font-size: 10px;">完全背包</a> <a href="/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/" style="font-size: 10px;">并查集</a> <a href="/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/" style="font-size: 10px;">归并排序</a> <a href="/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/" style="font-size: 10px;">快速幂</a> <a href="/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/" style="font-size: 10px;">拓扑排序</a> <a href="/tags/%E6%90%9C%E7%B4%A2/" style="font-size: 10px;">搜索</a> <a href="/tags/%E6%95%B0%E4%BD%8D-DP/" style="font-size: 10px;">数位 DP</a> <a href="/tags/%E6%95%B0%E8%AE%BA/" style="font-size: 10px;">数论</a> <a href="/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/" style="font-size: 10px;">最小生成树</a> <a href="/tags/%E6%A0%91/" style="font-size: 10px;">树</a> <a href="/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/" style="font-size: 10px;">线段树</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/" style="font-size: 10px;">计算几何</a> <a href="/tags/%E9%80%86%E5%BA%8F%E5%AF%B9/" style="font-size: 10px;">逆序对</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">July 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">December 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">November 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">November 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/07/25/2024-07-25-mac-manual/">Mac Manual</a>
          </li>
        
          <li>
            <a href="/2024/07/12/2024-07-12-emby/">Emby</a>
          </li>
        
          <li>
            <a href="/2024/07/02/2024-07-02-vps-xia-zai-ji/">VPS 下载机</a>
          </li>
        
          <li>
            <a href="/2022/12/17/2022-12-17-simplelogin/">SimpleLogin</a>
          </li>
        
          <li>
            <a href="/2022/11/11/2022-11-11-my-blog/">My Blog</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 OwlllOvO<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>